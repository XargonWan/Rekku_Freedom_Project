<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>%%BRAND_NAME%%</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #0d0d16;
            --surface: rgba(24, 24, 36, 0.9);
            --surface-alt: rgba(18, 18, 28, 0.75);
            --border: rgba(255, 255, 255, 0.08);
            --border-strong: rgba(255, 255, 255, 0.18);
            --accent: #ff6bd6;
            --accent-soft: rgba(255, 107, 214, 0.16);
            --text: #f5f5ff;
            --text-soft: #b9badc;
            --success: #18c98c;
            --warn: #f3c04d;
            --error: #ff7b93;
            --log-debug: #9aa0ff;
            --log-info: #d5d8ff;
            --log-warn: #ffde85;
            --log-error: #ff9fae;
            font-family: "Segoe UI", system-ui, sans-serif;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background:
                radial-gradient(circle at 20% 0%, rgba(114, 137, 218, 0.18), transparent 55%),
                radial-gradient(circle at 80% 100%, rgba(255, 107, 214, 0.22), transparent 55%),
                var(--bg);
            color: var(--text);
        }
        header.top-bar {
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            gap: 1.5rem;
            align-items: center;
            justify-content: space-between;
            padding: 1.2rem min(4vw, 2.4rem);
            background: linear-gradient(135deg, rgba(12, 12, 20, 0.78), rgba(34, 30, 46, 0.78));
            border-bottom: 1px solid var(--border);
            backdrop-filter: blur(18px);
        }
        .brand {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .brand img {
            width: 48px;
            height: 48px;
            border-radius: 14px;
            box-shadow: 0 16px 30px -22px rgba(114, 137, 218, 0.9);
        }
        .brand-text h1 {
            margin: 0;
            font-size: 1.45rem;
            letter-spacing: 0.08em;
        }
        .brand-text span {
            display: block;
            font-size: 0.85rem;
            color: var(--text-soft);
            letter-spacing: 0.08em;
        }
        nav.main-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
        }
        .nav-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            padding: 0.55rem 1.1rem;
            border-radius: 999px;
            border: 1px solid transparent;
            background: var(--surface-alt);
            color: var(--text-soft);
            font-size: 0.95rem;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: transform 0.15s ease, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        }
        .nav-btn .icon {
            font-size: 1.05rem;
        }
        .nav-btn.active {
            background: var(--accent);
            color: #07070c;
            box-shadow: 0 18px 35px -24px rgba(255, 107, 214, 0.95);
        }
        .nav-btn.active .icon {
            transform: scale(1.08);
        }
        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            font-size: 0.85rem;
            color: var(--text-soft);
            letter-spacing: 0.06em;
        }
        .connection-status .indicator {
            width: 0.7rem;
            height: 0.7rem;
            border-radius: 50%;
            background: #8585a2;
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }
        .connection-status .indicator.online {
            background: var(--success);
            box-shadow: 0 0 12px rgba(24, 201, 140, 0.7);
        }
        main {
            flex: 1;
            display: block;
            padding: 1.6rem min(4vw, 2.4rem) 3rem;
            width: 100%;
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        .home-stage {
            position: relative;
            border-radius: 26px;
            overflow: hidden;
            border: 1px solid var(--border);
            min-height: clamp(520px, 65vh, 760px);
            background: radial-gradient(circle at 20% 15%, rgba(255, 255, 255, 0.05), transparent 55%), rgba(16, 16, 28, 0.72);
            box-shadow: 0 28px 55px -42px rgba(0, 0, 0, 0.9);
        }
        #vrm-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        .home-overlay {
            position: absolute;
            inset: 0;
            padding: clamp(1.8rem, 3vw, 2.8rem);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            pointer-events: none;
            background: linear-gradient(180deg, rgba(12, 12, 20, 0.82) 0%, transparent 45%, rgba(12, 12, 20, 0.88) 100%);
        }
        .home-overlay h2 {
            margin: 0;
            font-size: clamp(1.9rem, 4vw, 2.8rem);
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }
        .home-overlay p {
            max-width: 42ch;
            font-size: clamp(0.98rem, 2vw, 1.12rem);
            color: var(--text-soft);
            line-height: 1.65;
        }
        #chat {
            --chat-height: 320px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: clamp(1.4rem, 3vw, 2.4rem);
            width: min(780px, calc(100% - 3rem));
            display: flex;
            flex-direction: column;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 22px;
            backdrop-filter: blur(16px);
            height: var(--chat-height);
            box-shadow: 0 24px 45px -38px rgba(0, 0, 0, 0.9);
        }
        #chat.resizing {
            cursor: ns-resize;
        }
        #chat-resize {
            height: 12px;
            width: 120px;
            margin: 0.45rem auto 0.2rem;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.16);
            position: relative;
            cursor: ns-resize;
        }
        #chat-resize::after {
            content: "";
            position: absolute;
            inset: 3px 30px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.2rem 1.4rem;
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
        }
        .bubble {
            max-width: 72ch;
            padding: 1rem 1.2rem;
            border-radius: 18px;
            line-height: 1.45;
            animation: fadeSlide 0.35s ease;
            white-space: pre-wrap;
            box-shadow: 0 18px 45px -38px rgba(0, 0, 0, 0.85);
        }
        .bubble.user {
            align-self: flex-end;
            background: rgba(255, 255, 255, 0.08);
        }
        .bubble.rekku {
            align-self: flex-start;
            background: linear-gradient(135deg, #ff6bd6, #7289da);
            color: #fff;
        }
        @keyframes fadeSlide {
            from {
                transform: translateY(10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        #composer {
            display: flex;
            gap: 0.8rem;
            padding: 1.1rem 1.4rem 1.4rem;
        }
        #input {
            flex: 1;
            resize: none;
            border-radius: 14px;
            padding: 0.9rem 1.1rem;
            border: 1px solid var(--border);
            background: rgba(12, 12, 20, 0.58);
            color: inherit;
            font-size: 1rem;
            line-height: 1.4;
            min-height: 2.8rem;
            max-height: 7rem;
        }
        #input:focus {
            outline: 2px solid var(--accent);
            outline-offset: 3px;
        }
        #send {
            padding: 0 1.5rem;
            border-radius: 16px;
            border: none;
            background: var(--accent);
            color: #04040a;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        #send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #send:hover:enabled {
            transform: translateY(-1px);
            box-shadow: 0 18px 30px -18px rgba(255, 107, 214, 0.85);
        }
        .logs-wrapper {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 22px;
            padding: clamp(1.2rem, 2vw, 1.8rem);
            box-shadow: 0 24px 45px -42px rgba(0, 0, 0, 0.85);
        }
        .log-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .log-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            align-items: center;
            font-size: 0.9rem;
        }
        .log-controls button {
            border: 1px solid var(--border);
            background: var(--surface-alt);
            color: var(--text);
            border-radius: 14px;
            padding: 0.6rem 1.1rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .log-controls button:hover {
            background: var(--accent-soft);
        }
        .log-controls label {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
        }
        #log-output {
            margin: 0;
            background: rgba(8, 8, 16, 0.82);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1rem 1.2rem;
            height: min(60vh, 540px);
            overflow-y: auto;
            font-family: "JetBrains Mono", "Fira Code", monospace;
            font-size: 0.88rem;
            line-height: 1.45;
            white-space: pre-wrap;
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }
        .log-line {
            word-break: break-word;
        }
        .log-line.level-debug {
            color: var(--log-debug);
        }
        .log-line.level-info {
            color: var(--log-info);
        }
        .log-line.level-warning {
            color: var(--log-warn);
        }
        .log-line.level-error {
            color: var(--log-error);
        }
        .log-line.level-other {
            color: var(--text-soft);
        }
        .settings-grid {
            display: grid;
            gap: clamp(1rem, 2vw, 1.6rem);
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 22px;
            padding: clamp(1.3rem, 2vw, 1.9rem);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 24px 45px -42px rgba(0, 0, 0, 0.85);
        }
        .card h2 {
            margin: 0;
            letter-spacing: 0.08em;
            font-size: 1.1rem;
            text-transform: uppercase;
        }
        .card p {
            margin: 0;
            color: var(--text-soft);
            line-height: 1.6;
        }
        .vrm-controls {
            display: flex;
            gap: 0.6rem;
            flex-wrap: wrap;
        }
        .pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.55rem 1.1rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 107, 214, 0.4);
            background: var(--accent-soft);
            color: inherit;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s ease, transform 0.15s ease;
        }
        .pill:hover {
            background: rgba(255, 107, 214, 0.24);
            transform: translateY(-1px);
        }
        .pill.secondary {
            border-color: rgba(114, 137, 218, 0.45);
            background: rgba(114, 137, 218, 0.16);
        }
        .pill.secondary:hover {
            background: rgba(114, 137, 218, 0.26);
        }
        #vrm-upload {
            display: none;
        }
        .vrm-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }
        .vrm-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.8rem;
            padding: 0.65rem 0.9rem;
            border: 1px solid var(--border);
            border-radius: 14px;
            background: rgba(10, 10, 18, 0.65);
            font-size: 0.9rem;
        }
        .vrm-list li.active {
            border-color: rgba(255, 107, 214, 0.65);
            background: rgba(255, 107, 214, 0.16);
        }
        .vrm-list li .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .vrm-actions {
            display: inline-flex;
            gap: 0.4rem;
        }
        .vrm-actions button {
            border: 1px solid var(--border);
            background: var(--surface-alt);
            color: inherit;
            padding: 0.45rem 0.9rem;
            border-radius: 12px;
            cursor: pointer;
        }
        .vrm-actions button:hover {
            background: var(--accent-soft);
        }
        .toggle {
            display: inline-flex;
            align-items: center;
            gap: 0.6rem;
            cursor: pointer;
            font-size: 0.95rem;
        }
        .toggle input {
            width: 1em;
            height: 1em;
            accent-color: var(--accent);
        }
        .status-chip {
            display: inline-flex;
            align-items: center;
            padding: 0.45rem 0.9rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            font-size: 0.85rem;
            color: var(--text-soft);
        }
        .status-chip[data-tone="success"] {
            color: var(--success);
            border-color: rgba(24, 201, 140, 0.4);
        }
        .status-chip[data-tone="warn"] {
            color: var(--warn);
            border-color: rgba(243, 192, 77, 0.4);
        }
        .status-chip[data-tone="error"] {
            color: var(--error);
            border-color: rgba(255, 123, 147, 0.4);
        }
        .links {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 0.6rem;
        }
        .links a {
            color: inherit;
            text-decoration: none;
            padding: 0.7rem 0.9rem;
            border-radius: 14px;
            border: 1px solid var(--border);
            transition: border 0.2s ease, background 0.2s ease;
        }
        .links a:hover {
            border-color: rgba(255, 107, 214, 0.6);
            background: rgba(255, 107, 214, 0.16);
        }
        dl {
            margin: 0;
        }
        dl div {
            display: flex;
            justify-content: space-between;
            padding: 0.45rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
        dl div:last-child {
            border-bottom: none;
        }
        dt {
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        dd {
            margin: 0;
            color: var(--text-soft);
        }
        @media (max-width: 960px) {
            header.top-bar {
                flex-wrap: wrap;
                justify-content: center;
                text-align: center;
            }
            .connection-status {
                order: 3;
            }
            .home-stage {
                min-height: clamp(480px, 70vh, 720px);
            }
            #chat {
                width: calc(100% - 2rem);
            }
        }
    </style>
</head>
<body>
    <header class="top-bar">
        <div class="brand">
            <img src="%%LOGO_URL%%" alt="SyntH logo" />
            <div class="brand-text">
                <h1>%%BRAND_NAME%%</h1>
                <span>Synthetic Heart Command Console</span>
            </div>
        </div>
        <nav class="main-nav" aria-label="Primary navigation">
            <button class="nav-btn active" data-tab="home" aria-controls="tab-home" aria-pressed="true">
                <span class="icon" aria-hidden="true">üè†</span><span>Home</span>
            </button>
            <button class="nav-btn" data-tab="logs" aria-controls="tab-logs" aria-pressed="false">
                <span class="icon" aria-hidden="true">üìú</span><span>Logs</span>
            </button>
            <button class="nav-btn" data-tab="settings" aria-controls="tab-settings" aria-pressed="false">
                <span class="icon" aria-hidden="true">‚öôÔ∏è</span><span>Settings</span>
            </button>
            <button class="nav-btn" data-tab="about" aria-controls="tab-about" aria-pressed="false">
                <span class="icon" aria-hidden="true">‚ÑπÔ∏è</span><span>About</span>
            </button>
        </nav>
        <div class="connection-status">
            <span class="indicator offline" aria-hidden="true"></span>
            <span id="status-label">Connecting‚Ä¶</span>
        </div>
    </header>
    <main>
        <section class="tab-panel active" id="tab-home" data-tab="home" role="tabpanel" aria-labelledby="home">
            <div class="home-stage">
                <canvas id="vrm-canvas"></canvas>
                <div class="home-overlay">
                    <div>
                        <h2>Welcome to SyntH: Synthetic Heart</h2>
                        <p>Orchestrate your companion, monitor live status, and keep the conversation flowing. The active VRM avatar will appear on this stage.</p>
                    </div>
                    <div></div>
                </div>
                <div id="chat" aria-label="Chat panel">
                    <div id="chat-resize" role="separator" aria-orientation="vertical"></div>
                    <div id="messages" aria-live="polite"></div>
                    <form id="composer" autocomplete="off">
                        <textarea id="input" placeholder="Type a message‚Ä¶" rows="2"></textarea>
                        <button id="send" type="submit" disabled>Send</button>
                    </form>
                </div>
            </div>
        </section>
        <section class="tab-panel" id="tab-logs" data-tab="logs" role="tabpanel">
            <div class="logs-wrapper">
                <div class="log-header">
                    <h2>Live Log Stream</h2>
                    <div class="log-controls">
                        <button id="logs-refresh" type="button">Reconnect</button>
                        <label><input type="checkbox" id="logs-autoscroll" checked /> Auto-scroll</label>
                        <label><input type="checkbox" class="log-filter" data-level="debug" checked /> Debug</label>
                        <label><input type="checkbox" class="log-filter" data-level="info" checked /> Info</label>
                        <label><input type="checkbox" class="log-filter" data-level="warning" checked /> Warning</label>
                        <label><input type="checkbox" class="log-filter" data-level="error" checked /> Error</label>
                        <label><input type="checkbox" class="log-filter" data-level="other" checked /> Other</label>
                    </div>
                </div>
                <div id="log-output"><div class="log-line level-info">Open the Logs tab to begin streaming‚Ä¶</div></div>
            </div>
        </section>
        <section class="tab-panel" id="tab-settings" data-tab="settings" role="tabpanel">
            <div class="settings-grid">
                <article class="card">
                    <h2>VRM Avatar</h2>
                    <p>Upload or select a VRM avatar. The active model renders on the Home stage.</p>
                    <div class="vrm-controls">
                        <input type="file" id="vrm-upload" accept=".vrm" />
                        <label class="pill" for="vrm-upload">Upload VRM</label>
                        <button class="pill secondary" type="button" id="vrm-refresh">Refresh List</button>
                    </div>
                    <ul class="vrm-list" id="vrm-list">
                        <li class="empty">No models available</li>
                    </ul>
                </article>
                <article class="card">
                    <h2>Notifications</h2>
                    <p>Enable desktop notifications and audio cues whenever new messages arrive.</p>
                    <label class="toggle">
                        <input type="checkbox" id="notify-toggle" />
                        <span>Enable desktop notifications</span>
                    </label>
                    <div id="notify-status" class="meta">Disabled</div>
                    <div id="connection" class="status-chip" data-tone="info">Ready.</div>
                </article>
            </div>
        </section>
        <section class="tab-panel" id="tab-about" data-tab="about" role="tabpanel">
            <div class="settings-grid">
                <article class="card">
                    <h2>Runtime Status</h2>
                    <dl>
                        <div><dt>Interface</dt><dd>%%BRAND_NAME%%</dd></div>
                        <div><dt>Uptime</dt><dd><span id="stats-uptime">--</span></dd></div>
                        <div><dt>Active sessions</dt><dd><span id="stats-sessions">--</span></dd></div>
                    </dl>
                </article>
                <article class="card">
                    <h2>Resources</h2>
                    <ul class="links">
                        <li><a href="https://github.com/XargonWan/Rekku_Freedom_Project/tree/develop" target="_blank" rel="noreferrer">Project repository</a></li>
                        <li><a href="https://rekku-freedom-project.readthedocs.io/en/latest/" target="_blank" rel="noreferrer">Documentation</a></li>
                        <li><a href="https://discord.gg/" target="_blank" rel="noreferrer">Community (coming soon)</a></li>
                    </ul>
                </article>
            </div>
        </section>
    </main>
    <script>
        const navButtons = document.querySelectorAll('.nav-btn');
        const tabPanels = document.querySelectorAll('.tab-panel');
        const statusLabel = document.getElementById('status-label');
        const statusIndicator = document.querySelector('.connection-status .indicator');
        const messages = document.getElementById('messages');
        const input = document.getElementById('input');
        const form = document.getElementById('composer');
        const sendBtn = document.getElementById('send');
        const uptimeEl = document.getElementById('stats-uptime');
        const sessionsEl = document.getElementById('stats-sessions');
        const connectionEl = document.getElementById('connection');
        const notifyToggle = document.getElementById('notify-toggle');
        const notifyStatus = document.getElementById('notify-status');
        const logOutput = document.getElementById('log-output');
        const logAutoscroll = document.getElementById('logs-autoscroll');
        const logFilters = document.querySelectorAll('.log-filter');
        const logsRefreshBtn = document.getElementById('logs-refresh');
        const chatPanel = document.getElementById('chat');
        const resizeHandle = document.getElementById('chat-resize');
        const NOTIFY_KEY = 'synth-webui-notify';
        const HISTORY_KEY = 'synth-webui-history';
        const HISTORY_LIMIT = 200;
        const LOG_BUFFER_LIMIT = 2000;
        const IS_SECURE = window.isSecureContext || window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        let ws = null;
        let sessionId = null;
        let notificationsEnabled = false;
        let audioContext = null;
        let historyBuffer = [];
        let logsSocket = null;
        let logsReconnectTimer = null;
        let activeTab = 'home';
        const logBuffer = [];
        const logFilterState = { debug: true, info: true, warning: true, error: true, other: true };

        function setStatusMessage(message, tone = 'info') {
            if (!connectionEl) return;
            connectionEl.textContent = message;
            connectionEl.dataset.tone = tone;
        }
        window.SynthWebUISetStatus = setStatusMessage;
        setStatusMessage('Ready.', 'info');

        function activateTab(tab) {
            if (!tab || activeTab === tab) return;
            activeTab = tab;
            navButtons.forEach((btn) => {
                const isActive = btn.dataset.tab === tab;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
            tabPanels.forEach((panel) => {
                panel.classList.toggle('active', panel.dataset.tab === tab);
            });
            if (tab === 'logs') {
                openLogStream();
            } else {
                closeLogStream();
            }
        }

        navButtons.forEach((btn) => {
            btn.addEventListener('click', () => activateTab(btn.dataset.tab));
        });

        function detectLogLevel(line) {
            const match = line.match(/\[(TRACE|DEBUG|INFO|WARN|WARNING|ERR|ERROR|CRITICAL)\]/i);
            if (!match) return 'other';
            const token = match[1].toLowerCase();
            if (token.includes('debug') || token.includes('trace')) return 'debug';
            if (token.includes('warn')) return 'warning';
            if (token.includes('err') || token.includes('critical')) return 'error';
            return 'info';
        }

        function renderLog() {
            if (!logOutput) return;
            const shouldScroll = logAutoscroll ? logAutoscroll.checked : true;
            logOutput.textContent = '';
            const fragment = document.createDocumentFragment();
            logBuffer.forEach(({ text, level }) => {
                if (!logFilterState[level]) return;
                const div = document.createElement('div');
                div.className = `log-line level-${level}`;
                div.textContent = text;
                fragment.appendChild(div);
            });
            logOutput.appendChild(fragment);
            if (shouldScroll) {
                logOutput.scrollTop = logOutput.scrollHeight;
            }
        }

        function appendLog(line) {
            const level = detectLogLevel(line);
            logBuffer.push({ text: line, level });
            if (logBuffer.length > LOG_BUFFER_LIMIT) {
                logBuffer.splice(0, logBuffer.length - LOG_BUFFER_LIMIT);
            }
            renderLog();
        }

        logFilters.forEach((checkbox) => {
            checkbox.addEventListener('change', (event) => {
                const level = event.target.dataset.level;
                logFilterState[level] = event.target.checked;
                renderLog();
            });
        });

        function openLogStream() {
            if (!logOutput) return;
            if (logsSocket && (logsSocket.readyState === WebSocket.OPEN || logsSocket.readyState === WebSocket.CONNECTING)) {
                return;
            }
            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            appendLog('--- connecting to log stream ---');
            logsSocket = new WebSocket(`${protocol}://${window.location.host}/logs`);
            logsSocket.addEventListener('open', () => {
                appendLog('--- log stream connected ---');
            });
            logsSocket.addEventListener('message', (event) => {
                appendLog(event.data);
            });
            logsSocket.addEventListener('close', () => {
                appendLog('--- log stream closed ---');
                logsSocket = null;
                if (activeTab === 'logs') {
                    clearTimeout(logsReconnectTimer);
                    logsReconnectTimer = setTimeout(() => openLogStream(), 3000);
                }
            });
            logsSocket.addEventListener('error', () => {
                appendLog('--- log stream error ---');
            });
        }

        function closeLogStream() {
            if (logsReconnectTimer) {
                clearTimeout(logsReconnectTimer);
                logsReconnectTimer = null;
            }
            if (logsSocket && logsSocket.readyState !== WebSocket.CLOSED) {
                try { logsSocket.close(); } catch (_) {}
            }
            logsSocket = null;
        }

        logsRefreshBtn?.addEventListener('click', () => {
            closeLogStream();
            openLogStream();
        });

        if (resizeHandle && chatPanel) {
            let resizing = false;
            let startY = 0;
            let startHeight = 320;
            resizeHandle.addEventListener('pointerdown', (event) => {
                resizing = true;
                startY = event.clientY;
                const current = parseFloat(getComputedStyle(chatPanel).getPropertyValue('--chat-height')) || chatPanel.offsetHeight;
                startHeight = current;
                chatPanel.classList.add('resizing');
                resizeHandle.setPointerCapture(event.pointerId);
            });
            const finishResize = (event) => {
                if (!resizing) return;
                resizing = false;
                chatPanel.classList.remove('resizing');
                if (event.pointerId !== undefined) {
                    try { resizeHandle.releasePointerCapture(event.pointerId); } catch (_) {}
                }
            };
            resizeHandle.addEventListener('pointermove', (event) => {
                if (!resizing) return;
                const delta = startY - event.clientY;
                let next = startHeight + delta;
                next = Math.min(Math.max(next, 200), 640);
                chatPanel.style.setProperty('--chat-height', `${next}px`);
            });
            resizeHandle.addEventListener('pointerup', finishResize);
            resizeHandle.addEventListener('pointercancel', finishResize);
        }

        function formatUptime(seconds) {
            if (Number.isNaN(seconds) || seconds < 0) return '--';
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const parts = [];
            if (hrs) parts.push(`${hrs}h`);
            if (mins || hrs) parts.push(`${mins}m`);
            parts.push(`${secs}s`);
            return parts.join(' ');
        }

        async function refreshStats(silent = false) {
            try {
                const res = await fetch('/stats');
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                if (uptimeEl) uptimeEl.textContent = formatUptime(Number(data.uptime || 0));
                if (sessionsEl) sessionsEl.textContent = Number(data.sessions || 0);
                if (!silent) setStatusMessage('Statistics updated', 'success');
            } catch (error) {
                if (!silent) setStatusMessage('Unable to fetch statistics', 'warn');
            }
        }

        function persistHistory() {
            try {
                if (!historyBuffer.length) {
                    localStorage.removeItem(HISTORY_KEY);
                    return;
                }
                localStorage.setItem(HISTORY_KEY, JSON.stringify(historyBuffer));
            } catch (error) {
                console.debug('[synth_webui] Unable to persist history', error);
            }
        }

        function restoreHistory() {
            try {
                const stored = localStorage.getItem(HISTORY_KEY);
                if (!stored) return;
                const parsed = JSON.parse(stored);
                if (!Array.isArray(parsed)) return;
                historyBuffer = parsed.slice(-HISTORY_LIMIT);
                historyBuffer.forEach(({ sender, text }) => addMessage(sender || 'rekku', text || '', false));
            } catch (error) {
                console.debug('[synth_webui] Unable to restore history', error);
            }
        }

        function ensureAudioContext(allowResume = false) {
            if (audioContext) {
                if (allowResume && audioContext.state === 'suspended') audioContext.resume();
                return;
            }
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (error) {
                console.debug('[synth_webui] Unable to create AudioContext', error);
            }
        }

        function playChime() {
            if (!audioContext) return;
            try {
                ensureAudioContext(true);
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start(now);
                osc.stop(now + 0.6);
            } catch (error) {
                console.debug('[synth_webui] Unable to play chime', error);
            }
        }

        function updateNotifyUI(enabled, silent = false) {
            notificationsEnabled = enabled && IS_SECURE;
            if (notifyToggle) notifyToggle.checked = notificationsEnabled;
            if (notifyStatus) {
                if (!IS_SECURE) {
                    notifyStatus.textContent = 'HTTPS or localhost required';
                } else {
                    notifyStatus.textContent = notificationsEnabled ? 'Enabled' : 'Disabled';
                }
            }
            localStorage.setItem(NOTIFY_KEY, notificationsEnabled ? '1' : '0');
            if (!silent) {
                const tone = notificationsEnabled ? 'success' : 'info';
                const message = notificationsEnabled ? 'Desktop notifications enabled' : 'Desktop notifications disabled';
                setStatusMessage(message, tone);
            }
        }

        function requestNotifications() {
            if (!IS_SECURE) {
                setStatusMessage('Notifications require HTTPS or localhost', 'warn');
                updateNotifyUI(false, true);
                return;
            }
            if (!('Notification' in window)) {
                setStatusMessage('This browser does not support desktop notifications', 'warn');
                updateNotifyUI(false, true);
                return;
            }
            Notification.requestPermission().then((permission) => {
                if (permission === 'granted') {
                    updateNotifyUI(true);
                } else {
                    updateNotifyUI(false, true);
                    setStatusMessage('Notifications blocked by the browser', 'warn');
                }
            }).catch(() => {
                updateNotifyUI(false, true);
                setStatusMessage('Unable to request notification permission', 'error');
            });
        }

        notifyToggle?.addEventListener('change', (event) => {
            if (event.target.checked) {
                ensureAudioContext(true);
                requestNotifications();
            } else {
                updateNotifyUI(false);
            }
        });

        (function bootstrapNotifications() {
            const saved = localStorage.getItem(NOTIFY_KEY) === '1';
            if (!IS_SECURE) {
                updateNotifyUI(false, true);
                return;
            }
            if (saved && 'Notification' in window && Notification.permission === 'granted') {
                updateNotifyUI(true, true);
            } else {
                updateNotifyUI(false, true);
            }
        })();

        function handleIncoming(text) {
            if (!notificationsEnabled) return;
            playChime();
            if (document.hidden && 'Notification' in window && Notification.permission === 'granted') {
                try {
                    const note = new Notification('New message', {
                        body: text,
                        tag: 'synth-webui-chat',
                        icon: '%%LOGO_URL%%'
                    });
                    setTimeout(() => note.close(), 5000);
                } catch (error) {
                    console.debug('[synth_webui] Notification error', error);
                }
            }
        }

        function addMessage(sender, text, persist = true) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble ' + (sender === 'rekku' ? 'rekku' : 'user');
            bubble.textContent = text;
            messages.appendChild(bubble);
            messages.scrollTop = messages.scrollHeight;

            if (sender === 'rekku') {
                handleIncoming(text);
            }

            if (persist) {
                historyBuffer.push({ sender, text });
                if (historyBuffer.length > HISTORY_LIMIT) {
                    historyBuffer = historyBuffer.slice(-HISTORY_LIMIT);
                }
                persistHistory();
            }
        }

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            setStatusMessage('Connecting‚Ä¶', 'info');
            ws = new WebSocket(`${protocol}://${window.location.host}/ws`);

            ws.addEventListener('open', () => {
                statusLabel.textContent = 'Connected';
                statusIndicator?.classList.add('online');
                sendBtn.disabled = false;
                setStatusMessage('Connection established.', 'success');
                refreshStats(true);
            });

            ws.addEventListener('message', (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'session') {
                    sessionId = data.session_id;
                    refreshStats(true);
                    return;
                }
                if (data.type === 'message') {
                    const sender = data.sender || 'rekku';
                    addMessage(sender, data.text || '');
                }
            });

            ws.addEventListener('close', () => {
                statusLabel.textContent = 'Disconnected';
                statusIndicator?.classList.remove('online');
                setStatusMessage('Connection lost. Reconnecting‚Ä¶', 'warn');
                sendBtn.disabled = true;
                setTimeout(connect, 1500);
            });

            ws.addEventListener('error', () => {
                setStatusMessage('Communication error.', 'error');
            });
        }

        form.addEventListener('submit', (event) => {
            event.preventDefault();
            const text = input.value.trim();
            if (!text || !ws || ws.readyState !== WebSocket.OPEN) {
                return;
            }
            addMessage('user', text);
            ws.send(JSON.stringify({ text }));
            input.value = '';
        });

        input.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                form.dispatchEvent(new Event('submit'));
            }
        });

        window.addEventListener('beforeunload', () => {
            try { if (ws) ws.close(); } catch (_) {}
            closeLogStream();
        });

        restoreHistory();
        activateTab(activeTab);
        connect();
        refreshStats(true);
        setInterval(() => refreshStats(true), 15000);
    </script>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/loaders/GLTFLoader.js';
        import { VRM, VRMLoaderPlugin, VRMUtils } from 'https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.0/lib/three-vrm.module.js';

        const canvas = document.getElementById('vrm-canvas');
        if (!canvas) {
            console.warn('[synth_webui] VRM canvas not found');
        } else {
            const setStatus = window.SynthWebUISetStatus || ((message) => console.log('[synth_webui]', message));
            const listEl = document.getElementById('vrm-list');
            const uploadInput = document.getElementById('vrm-upload');
            const refreshBtn = document.getElementById('vrm-refresh');
            let currentModel = null;
            let currentVRM = null;

            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setPixelRatio(window.devicePixelRatio);
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(30, canvas.clientWidth / Math.max(1, canvas.clientHeight), 0.1, 20);
            camera.position.set(0, 1.4, 2.2);

            const controls = new OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.enablePan = false;
            controls.target.set(0, 1.2, 0);
            controls.update();

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
            keyLight.position.set(1, 1.2, 1);
            scene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-1, 1.2, -1);
            scene.add(fillLight);

            const loader = new GLTFLoader();
            loader.setCrossOrigin('anonymous');
            loader.setResourcePath('/avatars/');
            loader.register((parser) => new VRMLoaderPlugin(parser));

            const blobLoader = new GLTFLoader();
            blobLoader.setCrossOrigin('anonymous');
            blobLoader.register((parser) => new VRMLoaderPlugin(parser));

            const clock = new THREE.Clock();

            function resizeRenderer() {
                const width = canvas.clientWidth;
                const height = canvas.clientHeight || 1;
                if (canvas.width !== width || canvas.height !== height) {
                    renderer.setSize(width, height, false);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
            }
            window.addEventListener('resize', resizeRenderer);
            resizeRenderer();

            function clearVRM() {
                if (currentVRM) {
                    scene.remove(currentVRM.scene);
                    currentVRM = null;
                }
            }

            async function loadVRM(url, name, { isObjectUrl = false } = {}) {
                if (!url) {
                    clearVRM();
                    currentModel = null;
                    setStatus('No active avatar', 'warn');
                    return;
                }
                try {
                    const targetLoader = isObjectUrl ? blobLoader : loader;
                    const cacheBusted = isObjectUrl ? url : (url.includes('?') ? `${url}&t=${Date.now()}` : `${url}?t=${Date.now()}`);
                    setStatus(`Loading avatar ${name}‚Ä¶`, 'info');
                    const gltf = await targetLoader.loadAsync(cacheBusted);
                    const vrm = gltf.userData.vrm || await VRM.from(gltf);
                    if (vrm && vrm.scene) {
                        VRMUtils.removeUnnecessaryJoints(vrm.scene);
                        VRMUtils.removeUnnecessaryVertices(vrm.scene);
                        if (vrm.meta?.metaVersion === '0') {
                            VRMUtils.rotateVRM0(vrm);
                        }
                        vrm.scene.rotation.y = Math.PI;
                        vrm.scene.position.set(0, 0, 0);
                        vrm.scene.traverse((obj) => {
                            obj.frustumCulled = false;
                        });
                    }
                    clearVRM();
                    scene.add(vrm.scene);
                    currentVRM = vrm;
                    currentModel = name;
                    setStatus(`Avatar ${name} loaded`, 'success');
                } catch (error) {
                    console.error('[synth_webui] Failed to load VRM', error);
                    setStatus('Unable to load the VRM model', 'error');
                }
            }

            function render() {
                requestAnimationFrame(render);
                const delta = clock.getDelta();
                if (currentVRM) currentVRM.update(delta);
                controls.update();
                resizeRenderer();
                renderer.render(scene, camera);
            }
            render();

            function renderList(data) {
                if (!listEl) return;
                listEl.innerHTML = '';
                if (!data.models.length) {
                    const li = document.createElement('li');
                    li.className = 'empty';
                    li.textContent = 'No models available';
                    listEl.appendChild(li);
                    clearVRM();
                    currentModel = null;
                    return;
                }
                data.models.forEach((model) => {
                    const li = document.createElement('li');
                    if (model.active) li.classList.add('active');
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'name';
                    nameSpan.textContent = model.name;
                    const actions = document.createElement('div');
                    actions.className = 'vrm-actions';

                    const activate = document.createElement('button');
                    activate.textContent = model.active ? 'Active' : 'Activate';
                    if (!model.active) {
                        activate.addEventListener('click', () => setActive(model.name));
                    } else {
                        activate.disabled = true;
                    }

                    const remove = document.createElement('button');
                    remove.textContent = 'Delete';
                    remove.addEventListener('click', () => removeModel(model.name));

                    actions.appendChild(activate);
                    actions.appendChild(remove);
                    li.appendChild(nameSpan);
                    li.appendChild(actions);
                    listEl.appendChild(li);
                });
            }

            async function refreshModels(feedback = false) {
                try {
                    const res = await fetch('/api/vrm');
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    const data = await res.json();
                    renderList(data);
                    const activeModel = data.models.find((item) => item.active);
                    if (activeModel && activeModel.name !== currentModel) {
                        await loadVRM(activeModel.url, activeModel.name);
                    } else if (!activeModel) {
                        clearVRM();
                        if (feedback) setStatus('No active avatar', 'warn');
                    } else if (feedback) {
                        setStatus('Avatar updated', 'success');
                    }
                } catch (error) {
                    console.error('[synth_webui] Unable to refresh models', error);
                    setStatus('Unable to refresh avatar list', 'error');
                }
            }

            async function setActive(name) {
                try {
                    const res = await fetch('/api/vrm/active', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name }),
                    });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    await refreshModels(true);
                } catch (error) {
                    console.error('[synth_webui] Failed to set active VRM', error);
                    setStatus('Unable to activate the model', 'error');
                }
            }

            async function removeModel(name) {
                if (!confirm(`Delete the model "${name}"?`)) return;
                try {
                    const res = await fetch(`/api/vrm/${encodeURIComponent(name)}`, {
                        method: 'DELETE',
                    });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    await refreshModels(true);
                } catch (error) {
                    console.error('[synth_webui] Failed to delete VRM', error);
                    setStatus('Unable to delete the model', 'error');
                }
            }

            uploadInput?.addEventListener('change', async (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                if (!file.name.toLowerCase().endsWith('.vrm')) {
                    setStatus('Select a valid .vrm file', 'warn');
                    uploadInput.value = '';
                    return;
                }
                const formData = new FormData();
                formData.append('file', file);
                setStatus('Uploading model‚Ä¶', 'info');
                try {
                    const res = await fetch('/api/vrm', {
                        method: 'POST',
                        body: formData,
                    });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    const payload = await res.json();
                    const localUrl = URL.createObjectURL(file);
                    await loadVRM(localUrl, payload.name, { isObjectUrl: true });
                    URL.revokeObjectURL(localUrl);
                    setStatus('Model uploaded successfully', 'success');
                    uploadInput.value = '';
                    await refreshModels();
                } catch (error) {
                    console.error('[synth_webui] Upload failed', error);
                    setStatus('Unable to upload the model', 'error');
                }
            });

            refreshBtn?.addEventListener('click', () => {
                refreshModels(true);
            });

            refreshModels().catch((error) => console.error(error));
        }
    </script>
</body>
</html>

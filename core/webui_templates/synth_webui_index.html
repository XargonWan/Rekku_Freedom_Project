<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>%%BRAND_NAME%%</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #0d0d16;
            --surface: rgba(24, 24, 36, 0.9);
            --surface-alt: rgba(18, 18, 28, 0.75);
            --border: rgba(255, 255, 255, 0.08);
            --border-strong: rgba(255, 255, 255, 0.18);
            --accent: #ff6bd6;
            --accent-soft: rgba(255, 107, 214, 0.16);
            --text: #f5f5ff;
            --text-soft: #b9badc;
            --success: #18c98c;
            --warn: #f3c04d;
            --error: #ff7b93;
            --log-debug: #9aa0ff;
            --log-info: #d5d8ff;
            --log-warn: #ffde85;
            --log-error: #ff9fae;
            font-family: "Segoe UI", system-ui, sans-serif;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background:
                radial-gradient(circle at 20% 0%, rgba(114, 137, 218, 0.18), transparent 55%),
                radial-gradient(circle at 80% 100%, rgba(255, 107, 214, 0.22), transparent 55%),
                var(--bg);
            color: var(--text);
        }
        header.top-bar {
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            gap: 1.5rem;
            align-items: center;
            justify-content: space-between;
            padding: 1.2rem min(4vw, 2.4rem);
            background: linear-gradient(135deg, rgba(12, 12, 20, 0.78), rgba(34, 30, 46, 0.78));
            border-bottom: 1px solid var(--border);
            backdrop-filter: blur(18px);
        }
        .brand {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .brand img {
            width: 48px;
            height: 48px;
            border-radius: 14px;
            box-shadow: 0 16px 30px -22px rgba(114, 137, 218, 0.9);
        }
        .brand-text h1 {
            margin: 0;
            font-size: 1.45rem;
            letter-spacing: 0.08em;
        }
        .brand-text span {
            display: block;
            font-size: 0.85rem;
            color: var(--text-soft);
            letter-spacing: 0.08em;
        }
        nav.main-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
        }
        .nav-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            padding: 0.55rem 1.1rem;
            border-radius: 999px;
            border: 1px solid transparent;
            background: var(--surface-alt);
            color: var(--text-soft);
            font-size: 0.95rem;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: transform 0.15s ease, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        }
        .nav-btn .icon {
            font-size: 1.05rem;
        }
        .nav-btn.active {
            background: var(--accent);
            color: #07070c;
            box-shadow: 0 18px 35px -24px rgba(255, 107, 214, 0.95);
        }
        .nav-btn.active .icon {
            transform: scale(1.08);
        }
        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            font-size: 0.85rem;
            color: var(--text-soft);
            letter-spacing: 0.06em;
        }
        .connection-status .indicator {
            width: 0.7rem;
            height: 0.7rem;
            border-radius: 50%;
            background: #8585a2;
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }
        .connection-status .indicator.online {
            background: var(--success);
            box-shadow: 0 0 12px rgba(24, 201, 140, 0.7);
        }
        main {
            flex: 1;
            display: block;
            padding: 1.6rem min(4vw, 2.4rem) 3rem;
            width: 100%;
        }
        .tab-panel {
            display: none;
            height: 100%;
        }
        .tab-panel.active {
            display: flex;
            flex-direction: column;
        }
        .home-stage {
            min-height: calc(100vh - 160px);
            display: flex;
            flex-direction: column;
            gap: 1.4rem;
            padding: clamp(1.8rem, 3vw, 2.6rem);
            border-radius: 26px;
            border: 1px solid var(--border);
            background: radial-gradient(circle at 20% 15%, rgba(255, 255, 255, 0.05), transparent 55%), rgba(16, 16, 28, 0.72);
            box-shadow: 0 28px 55px -42px rgba(0, 0, 0, 0.9);
            overflow: hidden;
        }
        .home-content {
            flex: 1;
            display: flex;
            position: relative;
            min-height: 0;
            gap: clamp(1.2rem, 3vw, 2.4rem);
            align-items: stretch;
        }
        #chat {
            position: relative;
            flex: 0 1 clamp(340px, 32%, 460px);
            display: flex;
            flex-direction: column;
            background: rgba(12, 12, 20, 0.92);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: none;
            border-radius: 22px;
            box-shadow: 0 24px 45px -38px rgba(0, 0, 0, 0.9);
            transition: transform 0.3s ease, opacity 0.3s ease;
            padding-top: 4rem;
            overflow: hidden;
        }
        #chat.hidden {
            display: none;
        }
        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.2rem 1.4rem;
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
        }
        .bubble {
            max-width: 72ch;
            padding: 1rem 1.2rem;
            border-radius: 18px;
            line-height: 1.45;
            animation: fadeSlide 0.35s ease;
            white-space: pre-wrap;
            box-shadow: 0 18px 45px -38px rgba(0, 0, 0, 0.85);
        }
        .bubble.user {
            align-self: flex-end;
            background: rgba(255, 255, 255, 0.08);
        }
        .bubble.rekku {
            align-self: flex-start;
            background: linear-gradient(135deg, #ff6bd6, #7289da);
            color: #fff;
        }
        .typing-indicator {
            display: flex;
            gap: 0.3rem;
            align-items: center;
            justify-content: center;
            padding: 1rem 1.5rem !important;
        }
        .typing-indicator .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.85);
            animation: typingDot 1.4s ease-in-out infinite;
        }
        .typing-indicator .dot:nth-child(1) {
            animation-delay: 0s;
        }
        .typing-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes typingDot {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }
        @keyframes fadeSlide {
            from {
                transform: translateY(10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        #composer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            padding: 1.1rem 1.4rem 1.4rem;
            align-items: flex-end;
        }
        #input {
            flex: 1;
            resize: none;
            border-radius: 14px;
            padding: 0.9rem 1.1rem;
            border: 1px solid var(--border);
            background: rgba(12, 12, 20, 0.58);
            color: inherit;
            font-size: 1rem;
            line-height: 1.4;
            min-height: 2.8rem;
            max-height: 7rem;
        }
        #input:focus {
            outline: 2px solid var(--accent);
            outline-offset: 3px;
        }
        #send {
            padding: 0 1.5rem;
            border-radius: 16px;
            border: none;
            background: var(--accent);
            color: #04040a;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        #send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #send:hover:enabled {
            transform: translateY(-1px);
            box-shadow: 0 18px 30px -18px rgba(255, 107, 214, 0.85);
        }
        .home-vrm {
            position: relative;
            flex: 1 1 auto;
            border-radius: 22px;
            border: none;
            background: rgba(12, 12, 20, 0.78);
            box-shadow: 0 24px 45px -38px rgba(0, 0, 0, 0.9);
            overflow: hidden;
            min-height: 420px;
        }
        .chat-toggle-btn {
            position: absolute;
            top: clamp(1.2rem, 2vw, 1.6rem);
            right: clamp(1.2rem, 2vw, 1.6rem);
            z-index: 100;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px solid var(--border);
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--accent);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            transition: all 0.25s ease;
        }
        .chat-toggle-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 107, 214, 0.15);
            border-color: var(--accent);
            box-shadow: 0 12px 32px rgba(255, 107, 214, 0.4);
        }
        .chat-toggle-btn:active {
            transform: scale(0.95);
        }
        .home-vrm canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .home-vrm-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            color: rgba(245, 245, 255, 0.6);
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        .logs-wrapper {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 22px;
            padding: clamp(1.2rem, 2vw, 1.8rem);
            box-shadow: 0 24px 45px -42px rgba(0, 0, 0, 0.85);
            height: calc(100vh - 220px);
            max-height: calc(100vh - 220px);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden;
        }
        .log-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .log-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            align-items: center;
            font-size: 0.9rem;
        }
        .log-controls button {
            border: 1px solid var(--border);
            background: var(--surface-alt);
            color: var(--text);
            border-radius: 14px;
            padding: 0.6rem 1.1rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .log-controls button:hover {
            background: var(--accent-soft);
        }
        .log-controls label {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
        }
        #log-output {
            margin: 0;
            background: rgba(8, 8, 16, 0.82);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1rem 1.2rem;
            overflow-y: auto;
            font-family: "JetBrains Mono", "Fira Code", monospace;
            font-size: 0.88rem;
            line-height: 1.45;
            white-space: pre-wrap;
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            flex: 1;
            min-height: 0;
        }
        .log-line {
            word-break: break-word;
        }
        .log-line.level-debug {
            color: var(--log-debug);
        }
        .log-line.level-info {
            color: var(--log-info);
        }
        .log-line.level-warning {
            color: var(--log-warn);
        }
        .log-line.level-error {
            color: var(--log-error);
        }
        .log-line.level-other {
            color: var(--text-soft);
        }
        .components-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        details.component-item {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 0.75rem 1rem;
            transition: background 0.2s ease, border 0.2s ease;
        }
        details.component-item[open] {
            background: rgba(255, 255, 255, 0.06);
        }
        details.component-item summary {
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.8rem;
            cursor: pointer;
            font-weight: 600;
        }
        details.component-item summary::-webkit-details-marker {
            display: none;
        }
        .component-summary-main {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            flex: 1 1 auto;
            min-width: 0;
        }
        .component-summary-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 0 0 auto;
        }
        .component-name {
            flex: 1 1 auto;
        }
        .component-status {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.09em;
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 999px;
            padding: 0.15rem 0.55rem;
        }
        .component-status-success {
            color: var(--success);
            border-color: rgba(24, 201, 140, 0.4);
        }
        .component-status-failed {
            color: var(--error);
            border-color: rgba(255, 123, 147, 0.5);
        }
        .component-status-loading {
            color: var(--warn);
            border-color: rgba(243, 192, 77, 0.5);
        }
        .component-status-unknown {
            color: var(--text-soft);
            border-color: rgba(255, 255, 255, 0.2);
        }
        .component-flag {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            border-radius: 999px;
            padding: 0.15rem 0.55rem;
            background: var(--accent);
            color: #040404;
        }
        .component-flag-secondary {
            background: rgba(114, 137, 218, 0.25);
            color: var(--text);
        }
        .component-description {
            margin: 0.6rem 0;
            color: var(--text-soft);
        }
        .component-details {
            font-size: 0.85rem;
            color: var(--text-soft);
        }
        .component-error {
            font-size: 0.85rem;
            color: var(--error);
        }
        .component-actions {
            margin-top: 0.75rem;
        }
        .component-actions-heading {
            margin: 0 0 0.4rem 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        .component-action-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .component-action-list li {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 0.6rem 0.8rem;
        }
        .component-action-title {
            font-weight: 600;
        }
        .component-action-description {
            margin: 0.35rem 0;
            color: var(--text-soft);
            font-size: 0.9rem;
        }
        .component-action-meta {
            font-size: 0.8rem;
            color: var(--text-soft);
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        .component-action-meta span {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 999px;
            padding: 0.2rem 0.5rem;
        }
        .config-list {
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
        }
        .config-row {
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
            padding: 0.85rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.04);
        }
        .config-label-line {
            display: flex;
            align-items: center;
            gap: 0.45rem;
            font-weight: 600;
        }
        .config-label-sub {
            font-size: 0.8rem;
            color: var(--text-soft);
            letter-spacing: 0.05em;
        }
        .config-input {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }
        .config-input input,
        .config-input select {
            flex: 1;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: rgba(12, 12, 20, 0.58);
            color: var(--text);
            padding: 0.55rem 0.85rem;
            font-size: 0.95rem;
        }
        .config-input input:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }
        /* Toggle Switch for Boolean Settings */
        .config-input input[type="checkbox"] {
            display: none; /* Hide default checkbox */
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
            flex: 0 0 auto;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.15);
            transition: 0.3s;
            border-radius: 26px;
            border: 1px solid var(--border);
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #fff;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        input[type="checkbox"]:checked + .toggle-slider {
            background: linear-gradient(135deg, #ff6bd6, #7289da);
            border-color: #ff6bd6;
        }
        input[type="checkbox"]:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
        input[type="checkbox"]:disabled + .toggle-slider {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .config-description {
            font-size: 0.85rem;
            color: var(--text-soft);
            line-height: 1.45;
        }
        .config-disclaimer {
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-soft);
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .override-icon {
            color: var(--warn);
            font-weight: 600;
        }
        .warning-card {
            border: 1px solid rgba(243, 192, 77, 0.4);
        }
        .warning-card .warning-text {
            margin-bottom: 0.8rem;
            background: rgba(243, 192, 77, 0.15);
            border-radius: 12px;
            padding: 0.65rem 0.9rem;
            color: var(--warn);
            font-size: 0.9rem;
        }
        .component-summary-actions button.pill {
            padding: 0.35rem 0.9rem;
        }
        .settings-grid {
            display: flex;
            flex-wrap: wrap;
            gap: clamp(1rem, 2vw, 1.6rem);
            align-items: stretch;
        }
        .settings-grid > .card {
            flex: 1 1 auto;
            min-width: 280px;
        }
        #tab-settings .settings-grid {
            flex-direction: column;
        }
        #tab-settings .settings-grid > .card {
            max-width: none;
            width: 100%;
        }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 22px;
            padding: clamp(1.3rem, 2vw, 1.9rem);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 24px 45px -42px rgba(0, 0, 0, 0.85);
        }
        .card h2 {
            margin: 0;
            letter-spacing: 0.08em;
            font-size: 1.1rem;
            text-transform: uppercase;
        }
        .card p {
            margin: 0;
            color: var(--text-soft);
            line-height: 1.6;
        }
        .vrm-controls {
            display: flex;
            gap: 0.6rem;
            flex-wrap: wrap;
        }
        .pill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.55rem 1.1rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 107, 214, 0.4);
            background: var(--accent-soft);
            color: inherit;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s ease, transform 0.15s ease;
        }
        .pill:hover {
            background: rgba(255, 107, 214, 0.24);
            transform: translateY(-1px);
        }
        .pill.secondary {
            border-color: rgba(114, 137, 218, 0.45);
            background: rgba(114, 137, 218, 0.16);
        }
        .pill.secondary:hover {
            background: rgba(114, 137, 218, 0.26);
        }
        #vrm-upload {
            display: none;
        }
        .vrm-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }
        .vrm-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.8rem;
            padding: 0.65rem 0.9rem;
            border: 1px solid var(--border);
            border-radius: 14px;
            background: rgba(10, 10, 18, 0.65);
            font-size: 0.9rem;
        }
        .vrm-list li.active {
            border-color: rgba(255, 107, 214, 0.65);
            background: rgba(255, 107, 214, 0.16);
        }
        .vrm-list li .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .vrm-actions {
            display: inline-flex;
            gap: 0.4rem;
        }
        .vrm-actions button {
            border: 1px solid var(--border);
            background: var(--surface-alt);
            color: inherit;
            padding: 0.45rem 0.9rem;
            border-radius: 12px;
            cursor: pointer;
        }
        .vrm-actions button:hover {
            background: var(--accent-soft);
        }
        .toggle {
            display: inline-flex;
            align-items: center;
            gap: 0.6rem;
            cursor: pointer;
            font-size: 0.95rem;
        }
        .toggle input {
            width: 1em;
            height: 1em;
            accent-color: var(--accent);
        }
        .status-chip {
            display: inline-flex;
            align-items: center;
            padding: 0.45rem 0.9rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            font-size: 0.85rem;
            color: var(--text-soft);
        }
        .status-chip[data-tone="success"] {
            color: var(--success);
            border-color: rgba(24, 201, 140, 0.4);
        }
        .status-chip[data-tone="warn"] {
            color: var(--warn);
            border-color: rgba(243, 192, 77, 0.4);
        }
        .status-chip[data-tone="error"] {
            color: var(--error);
            border-color: rgba(255, 123, 147, 0.4);
        }
        .links {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 0.6rem;
        }
        .links a {
            color: inherit;
            text-decoration: none;
            padding: 0.7rem 0.9rem;
            border-radius: 14px;
            border: 1px solid var(--border);
            transition: border 0.2s ease, background 0.2s ease;
        }
        .links a:hover {
            border-color: rgba(255, 107, 214, 0.6);
            background: rgba(255, 107, 214, 0.16);
        }
        dl {
            margin: 0;
        }
        dl div {
            display: flex;
            justify-content: space-between;
            padding: 0.45rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
        dl div:last-child {
            border-bottom: none;
        }
        dt {
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        dd {
            margin: 0;
            color: var(--text-soft);
        }
        @media (max-width: 960px) {
            header.top-bar {
                flex-wrap: wrap;
                justify-content: center;
                text-align: center;
            }
            .connection-status {
                order: 3;
            }
            .home-stage {
                min-height: calc(100vh - 140px);
                padding: clamp(1.2rem, 4vw, 1.8rem);
            }
            .home-content {
                flex-direction: column;
            }
            #chat {
                flex: 0 0 auto;
                width: 100%;
                padding-top: 3.5rem;
            }
            .home-vrm {
                min-height: clamp(320px, 50vh, 560px);
            }
            .chat-toggle-btn {
                top: 1rem;
                right: 1rem;
                width: 48px;
                height: 48px;
                font-size: 1.3rem;
            }
        }
        @media (max-width: 600px) {
            #composer {
                flex-direction: column;
                align-items: stretch;
            }
            #send {
                width: 100%;
                padding: 0.9rem;
            }
            #input {
                min-height: 3.5rem;
            }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(34, 197, 94, 0.95);
            color: #fff;
            padding: 0.875rem 1.5rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.95rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);
            z-index: 10000;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast.error {
            background: rgba(239, 68, 68, 0.95);
        }
    </style>
</head>
<body>
    <header class="top-bar">
        <div class="brand">
            <img src="%%LOGO_URL%%" alt="SyntH logo" />
            <div class="brand-text">
                <h1>%%BRAND_NAME%%</h1>
                <span>Synthetic Heart Command Console</span>
            </div>
        </div>
        <nav class="main-nav" aria-label="Primary navigation">
            <button class="nav-btn active" data-tab="home" aria-controls="tab-home" aria-pressed="true">
                <span class="icon" aria-hidden="true">🏠</span><span>Home</span>
            </button>
            <button class="nav-btn" data-tab="logs" aria-controls="tab-logs" aria-pressed="false">
                <span class="icon" aria-hidden="true">📜</span><span>Logs</span>
            </button>
            <button class="nav-btn" data-tab="settings" aria-controls="tab-settings" aria-pressed="false">
                <span class="icon" aria-hidden="true">⚙️</span><span>Settings</span>
            </button>
            <button class="nav-btn" data-tab="components" aria-controls="tab-components" aria-pressed="false">
                <span class="icon" aria-hidden="true">🧩</span><span>Components</span>
            </button>
            <button class="nav-btn" data-tab="about" aria-controls="tab-about" aria-pressed="false">
                <span class="icon" aria-hidden="true">ℹ️</span><span>About</span>
            </button>
        </nav>
        <div class="connection-status">
            <span class="indicator offline" aria-hidden="true"></span>
            <span id="status-label">Connecting…</span>
        </div>
    </header>
    <main>
        <section class="tab-panel active" id="tab-home" data-tab="home" role="tabpanel" aria-labelledby="home">
            <div class="home-stage">
                <div class="home-content">
                    <button id="chat-toggle" class="chat-toggle-btn" type="button" aria-label="Toggle chat visibility" title="Show/Hide Chat">
                        💬
                    </button>
                    <section id="chat" aria-label="Chat panel">
                        <div id="messages" aria-live="polite"></div>
                        <form id="composer" autocomplete="off">
                            <textarea id="input" placeholder="Type a message…" rows="2"></textarea>
                            <button id="send" type="submit" disabled>Send</button>
                        </form>
                    </section>
                    <div class="home-vrm">
                        <canvas id="vrm-canvas"></canvas>
                    </div>
                </div>
            </div>
        </section>
        <section class="tab-panel" id="tab-logs" data-tab="logs" role="tabpanel">
            <div class="logs-wrapper">
                <div class="log-header">
                    <h2>Live Log Stream</h2>
                    <div class="log-controls">
                        <button id="logs-refresh" type="button">Reconnect</button>
                        <label><input type="checkbox" id="logs-autoscroll" checked /> Auto-scroll</label>
                        <input type="text" id="log-search" placeholder="Search logs..." style="padding: 0.4rem 0.8rem; border-radius: 6px; border: 1px solid var(--border); background: rgba(12, 12, 20, 0.58); color: inherit; margin-left: 1rem; min-width: 200px;" />
                        <label><input type="checkbox" class="log-filter" data-level="debug" checked /> Debug</label>
                        <label><input type="checkbox" class="log-filter" data-level="info" checked /> Info</label>
                        <label><input type="checkbox" class="log-filter" data-level="warning" checked /> Warning</label>
                        <label><input type="checkbox" class="log-filter" data-level="error" checked /> Error</label>
                        <label><input type="checkbox" class="log-filter" data-level="other" checked /> Other</label>
                        <label style="margin-left: 1rem;">
                            Web UI Log Level:
                            <select id="webui-log-level" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem;">
                                <option value="debug">DEBUG</option>
                                <option value="info" selected>INFO</option>
                                <option value="warning">WARNING</option>
                                <option value="error">ERROR</option>
                                <option value="critical">CRITICAL</option>
                            </select>
                        </label>
                        <label style="margin-left: 1rem;">
                            LogChat Notification Level:
                            <select id="logchat-level" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem;">
                                <option value="DEBUG">DEBUG</option>
                                <option value="INFO">INFO</option>
                                <option value="WARNING">WARNING</option>
                                <option value="ERROR" selected>ERROR</option>
                                <option value="NONE">NONE</option>
                            </select>
                        </label>
                    </div>
                </div>
                <div id="log-output"><div class="log-line level-info">Open the Logs tab to begin streaming…</div></div>
            </div>
        </section>
        <section class="tab-panel" id="tab-settings" data-tab="settings" role="tabpanel">
            <div class="settings-grid">
                <article class="card">
                    <h2>VRM Avatar</h2>
                    <p>Upload or select a VRM avatar. The active model renders on the Home stage.</p>
                    <div class="vrm-controls">
                        <input type="file" id="vrm-upload" accept=".vrm" />
                        <label class="pill" for="vrm-upload">Upload VRM</label>
                        <button class="pill secondary" type="button" id="vrm-refresh">Refresh List</button>
                    </div>
                    <ul class="vrm-list" id="vrm-list">
                        <li class="empty">No models available</li>
                    </ul>
                </article>
                <article class="card">
                    <h2>Notifications</h2>
                    <p>Enable desktop notifications and audio cues whenever new messages arrive.</p>
                    <label class="toggle">
                        <input type="checkbox" id="notify-toggle" />
                        <span>Enable desktop notifications</span>
                    </label>
                    <div id="notify-status" class="meta">Disabled</div>
                    <div id="connection" class="status-chip" data-tone="info">Ready.</div>
                </article>
                <article class="card" id="config-general-card">
                    <h2>Configuration</h2>
                    <div class="config-list" id="config-general-list">
                        <div class="meta">Loading…</div>
                    </div>
                    <div class="config-disclaimer" id="config-env-disclaimer">
                        <span class="override-icon">⚠️</span> Variables with this icon are overridden by environment values. Remove the override to enable editing.
                    </div>
                </article>
                <article class="card warning-card" id="config-advanced-card">
                    <h2>Advanced Settings</h2>
                    <p class="warning-text" id="config-advanced-warning">Changing ports may render the service unavailable. Update Docker compose exposure before applying modifications.</p>
                    <div class="config-list" id="config-advanced-list">
                        <div class="meta">Loading…</div>
                    </div>
                </article>
            </div>
        </section>
        <section class="tab-panel" id="tab-components" data-tab="components" role="tabpanel">
            <div class="settings-grid">
                <article class="card">
                    <h2>LLM Engines</h2>
                    <div id="components-llm">
                        <div class="meta" id="components-llm-summary">Loading…</div>
                        <div class="components-list" id="components-llm-list"></div>
                    </div>
                </article>
                <article class="card">
                    <h2>Interfaces</h2>
                    <div class="components-list" id="components-interfaces-list">
                        <div class="meta">Loading…</div>
                    </div>
                </article>
                <article class="card">
                    <h2>Plugins</h2>
                    <div class="components-list" id="components-plugins-list">
                        <div class="meta">Loading…</div>
                    </div>
                </article>
            </div>
        </section>
        <section class="tab-panel" id="tab-about" data-tab="about" role="tabpanel">
            <div class="settings-grid">
                <article class="card">
                    <h2>Runtime Status</h2>
                    <dl>
                        <div><dt>Interface</dt><dd>%%BRAND_NAME%%</dd></div>
                        <div><dt>Uptime</dt><dd><span id="stats-uptime">--</span></dd></div>
                        <div><dt>Active sessions</dt><dd><span id="stats-sessions">--</span></dd></div>
                    </dl>
                </article>
                <article class="card">
                    <h2>Resources</h2>
                    <ul class="links">
                        <li><a href="https://github.com/XargonWan/Rekku_Freedom_Project/tree/develop" target="_blank" rel="noreferrer">Project repository</a></li>
                        <li><a href="https://rekku-freedom-project.readthedocs.io/en/latest/" target="_blank" rel="noreferrer">Documentation</a></li>
                        <li><a href="https://discord.gg/" target="_blank" rel="noreferrer">Community (coming soon)</a></li>
                    </ul>
                </article>
            </div>
        </section>
    </main>
    <script>
        // Configuration values from server
        window.RESPONSE_TIMEOUT = %%RESPONSE_TIMEOUT%%;
        window.FAILED_MESSAGE_TEXT = "%%FAILED_MESSAGE_TEXT%%";
        
        const navButtons = document.querySelectorAll('.nav-btn');
        const tabPanels = document.querySelectorAll('.tab-panel');
        const statusLabel = document.getElementById('status-label');
        const statusIndicator = document.querySelector('.connection-status .indicator');
        const messages = document.getElementById('messages');
        const input = document.getElementById('input');
        const form = document.getElementById('composer');
        const sendBtn = document.getElementById('send');
        const uptimeEl = document.getElementById('stats-uptime');
        const sessionsEl = document.getElementById('stats-sessions');
        const connectionEl = document.getElementById('connection');
        const notifyToggle = document.getElementById('notify-toggle');
        const notifyStatus = document.getElementById('notify-status');
        const logOutput = document.getElementById('log-output');
        const logAutoscroll = document.getElementById('logs-autoscroll');
        const logFilters = document.querySelectorAll('.log-filter');
        const logsRefreshBtn = document.getElementById('logs-refresh');
        const logSearchInput = document.getElementById('log-search');
        const chatPanel = document.getElementById('chat');
        const chatToggleBtn = document.getElementById('chat-toggle');
        const componentsLLMSummary = document.getElementById('components-llm-summary');
        const componentsLLMList = document.getElementById('components-llm-list');
        const componentsInterfacesList = document.getElementById('components-interfaces-list');
        const componentsPluginsList = document.getElementById('components-plugins-list');
        const configGeneralList = document.getElementById('config-general-list');
        const configAdvancedList = document.getElementById('config-advanced-list');
        const configDisclaimer = document.getElementById('config-env-disclaimer');
        const configAdvancedWarning = document.getElementById('config-advanced-warning');
        const NOTIFY_KEY = 'synth-webui-notify';
        const HISTORY_KEY = 'synth-webui-history';
        const TAB_KEY = 'synth-webui-active-tab';
        const HISTORY_LIMIT = 200;
        const LOG_BUFFER_LIMIT = 2000;
        const IS_SECURE = window.isSecureContext || window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        let ws = null;
        let sessionId = null;
        let notificationsEnabled = false;
        let audioContext = null;
        let historyBuffer = [];
        let logsSocket = null;
        let logsReconnectTimer = null;
        let activeTab = localStorage.getItem(TAB_KEY) || 'home';
        const logBuffer = [];
        const logFilterState = { debug: true, info: true, warning: true, error: true, other: true };
        let logSearchTerm = '';
        let componentsLoading = false;
        let componentsLoaded = false;
        let configLoading = false;
        let configLoaded = false;
        let typingIndicator = null;  // Reference to typing indicator bubble
        let typingTimeoutTimer = null;  // Timer for typing indicator timeout
        let interfaceOptions = [];
        let interfaceOptionsLoading = false;
        const EMOJI_CATALOG = [
            '😀','😁','😂','🤣','😊','😍','😘','😇','😉','😎',
            '🥳','🤔','🤗','🙂','🙃','😏','😌','😴','🤤','😠',
            '😢','😭','😤','😱','😳','🥺','🤯','😬','😡','🤡',
            '👀','👍','👎','👏','🙌','🙏','🤝','🔥','✨','💫',
            '💖','💔','❤️','💜','💙','💚','🧡','🤍','🤎','🖤'
        ];
        let emojiPickerElement = null;
        let currentEmojiTarget = null;

        function setStatusMessage(message, tone = 'info') {
            if (!connectionEl) return;
            connectionEl.textContent = message;
            connectionEl.dataset.tone = tone;
        }
        window.SynthWebUISetStatus = setStatusMessage;
        setStatusMessage('Ready.', 'info');

        // Toast notification function
        let toastTimeout = null;
        function showToast(message, isError = false, duration = 2000) {
            // Remove existing toast if any
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }
            if (toastTimeout) {
                clearTimeout(toastTimeout);
            }

            // Create new toast
            const toast = document.createElement('div');
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.textContent = message;
            document.body.appendChild(toast);

            // Trigger animation
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });
            });

            // Remove after specified duration
            toastTimeout = setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        function setInterfaceOptionsFromComponents(interfaces) {
            if (!Array.isArray(interfaces)) {
                return;
            }
            const normalized = interfaces
                .map((iface) => {
                    const name = (iface?.name || '').trim();
                    if (!name) return null;
                    const displayName = (iface?.display_name || name).trim();
                    return { name, displayName };
                })
                .filter(Boolean);
            if (normalized.length) {
                interfaceOptions = normalized;
            }
        }

        async function ensureInterfaceOptions(force = false) {
            if (!force && interfaceOptions.length) {
                return interfaceOptions;
            }
            if (interfaceOptionsLoading) {
                return interfaceOptions;
            }
            interfaceOptionsLoading = true;
            try {
                const res = await fetch('/api/components');
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const payload = await res.json();
                if (payload && Array.isArray(payload.interfaces)) {
                    setInterfaceOptionsFromComponents(payload.interfaces);
                }
            } catch (error) {
                console.error('[synth_webui] Unable to load interface list', error);
            } finally {
                interfaceOptionsLoading = false;
            }
            return interfaceOptions;
        }

        function buildEmojiPicker() {
            if (emojiPickerElement) return emojiPickerElement;
            const picker = document.createElement('div');
            picker.className = 'emoji-picker';
            picker.style.cssText = `
                position: absolute;
                display: none;
                grid-template-columns: repeat(10, 2.2rem);
                gap: 0.35rem;
                padding: 0.6rem;
                border-radius: 12px;
                background: rgba(15, 15, 24, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.08);
                box-shadow: 0 18px 35px -20px rgba(0, 0, 0, 0.65);
                z-index: 10050;
            `;
            EMOJI_CATALOG.forEach((emoji) => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.textContent = emoji;
                btn.style.cssText = `
                    font-size: 1.4rem;
                    width: 2.2rem;
                    height: 2.2rem;
                    border-radius: 8px;
                    border: 1px solid transparent;
                    background: transparent;
                    cursor: pointer;
                    transition: transform 0.15s ease, background 0.2s ease;
                `;
                btn.addEventListener('mouseenter', () => {
                    btn.style.background = 'rgba(255, 255, 255, 0.08)';
                });
                btn.addEventListener('mouseleave', () => {
                    btn.style.background = 'transparent';
                });
                btn.addEventListener('click', () => {
                    if (!currentEmojiTarget) return;
                    currentEmojiTarget.value = emoji;
                    const changeEvent = new Event('change', { bubbles: true });
                    currentEmojiTarget.dispatchEvent(changeEvent);
                    hideEmojiPicker();
                });
                picker.appendChild(btn);
            });
            document.body.appendChild(picker);
            emojiPickerElement = picker;
            document.addEventListener('click', (event) => {
                if (!emojiPickerElement || emojiPickerElement.style.display !== 'grid') return;
                const target = event.target;
                if (target === emojiPickerElement) return;
                if (emojiPickerElement.contains(target)) return;
                if (currentEmojiTarget && target === currentEmojiTarget) return;
                hideEmojiPicker();
            });
            return picker;
        }

        function showEmojiPicker(targetInput, triggerEvent) {
            if (!targetInput || targetInput.disabled) return;
            const picker = buildEmojiPicker();
            currentEmojiTarget = targetInput;
            const rect = targetInput.getBoundingClientRect();
            picker.style.display = 'grid';
            const top = rect.bottom + window.scrollY + 8;
            const left = rect.left + window.scrollX;
            picker.style.top = `${top}px`;
            picker.style.left = `${left}px`;
        }

        function hideEmojiPicker() {
            if (emojiPickerElement) {
                emojiPickerElement.style.display = 'none';
            }
            currentEmojiTarget = null;
        }

        function activateTab(tab, force = false) {
            if (!tab) return;
            const currentPanelActive = document.querySelector(`.tab-panel.active[data-tab="${tab}"]`) !== null;
            if (!force && activeTab === tab && currentPanelActive) return;
            activeTab = tab;
            localStorage.setItem(TAB_KEY, tab);
            navButtons.forEach((btn) => {
                const isActive = btn.dataset.tab === tab;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
            tabPanels.forEach((panel) => {
                panel.classList.toggle('active', panel.dataset.tab === tab);
            });
            if (tab === 'logs') {
                openLogStream();
            } else {
                closeLogStream();
            }
            if (tab === 'components') {
                refreshComponents(true);
            }
            if (tab === 'settings') {
                refreshConfig();
            }
        }

        navButtons.forEach((btn) => {
            btn.addEventListener('click', () => activateTab(btn.dataset.tab));
        });

        function detectLogLevel(line) {
            const match = line.match(/\[(TRACE|DEBUG|INFO|WARN|WARNING|ERR|ERROR|CRITICAL)\]/i);
            if (!match) return 'other';
            const token = match[1].toLowerCase();
            if (token.includes('debug') || token.includes('trace')) return 'debug';
            if (token.includes('warn')) return 'warning';
            if (token.includes('err') || token.includes('critical')) return 'error';
            return 'info';
        }

        function renderLog() {
            if (!logOutput) return;
            const shouldScroll = logAutoscroll ? logAutoscroll.checked : true;
            const searchLower = logSearchTerm.toLowerCase();
            logOutput.textContent = '';
            const fragment = document.createDocumentFragment();
            logBuffer.forEach(({ text, level }) => {
                if (!logFilterState[level]) return;
                // Apply search filter if search term is not empty
                if (searchLower && !text.toLowerCase().includes(searchLower)) return;
                const div = document.createElement('div');
                div.className = `log-line level-${level}`;
                // Highlight search term if present
                if (searchLower && text.toLowerCase().includes(searchLower)) {
                    const parts = text.split(new RegExp(`(${logSearchTerm})`, 'gi'));
                    div.innerHTML = '';
                    parts.forEach(part => {
                        if (part.toLowerCase() === searchLower) {
                            const mark = document.createElement('mark');
                            mark.style.background = 'var(--accent)';
                            mark.style.color = '#04040a';
                            mark.style.padding = '0 2px';
                            mark.style.borderRadius = '2px';
                            mark.textContent = part;
                            div.appendChild(mark);
                        } else {
                            div.appendChild(document.createTextNode(part));
                        }
                    });
                } else {
                    div.textContent = text;
                }
                fragment.appendChild(div);
            });
            logOutput.appendChild(fragment);
            if (shouldScroll) {
                logOutput.scrollTop = logOutput.scrollHeight;
            }
        }

        function appendLog(line) {
            const level = detectLogLevel(line);
            logBuffer.push({ text: line, level });
            if (logBuffer.length > LOG_BUFFER_LIMIT) {
                logBuffer.splice(0, logBuffer.length - LOG_BUFFER_LIMIT);
            }
            renderLog();
        }

        logFilters.forEach((checkbox) => {
            checkbox.addEventListener('change', (event) => {
                const level = event.target.dataset.level;
                logFilterState[level] = event.target.checked;
                renderLog();
            });
        });

        if (logSearchInput) {
            logSearchInput.addEventListener('input', (event) => {
                logSearchTerm = event.target.value;
                renderLog();
            });
        }

        function openLogStream() {
            if (!logOutput) return;
            if (logsSocket && (logsSocket.readyState === WebSocket.OPEN || logsSocket.readyState === WebSocket.CONNECTING)) {
                return;
            }
            
            // Immediately scroll to bottom without animation when opening logs tab
            if (logOutput.scrollHeight > 0) {
                logOutput.scrollTop = logOutput.scrollHeight;
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            appendLog('--- connecting to log stream ---');
            logsSocket = new WebSocket(`${protocol}://${window.location.host}/logs`);
            logsSocket.addEventListener('open', () => {
                appendLog('--- log stream connected ---');
                // Scroll to bottom again after connection
                if (logOutput) {
                    logOutput.scrollTop = logOutput.scrollHeight;
                }
            });
            logsSocket.addEventListener('message', (event) => {
                appendLog(event.data);
            });
            logsSocket.addEventListener('close', () => {
                appendLog('--- log stream closed ---');
                logsSocket = null;
                if (activeTab === 'logs') {
                    clearTimeout(logsReconnectTimer);
                    logsReconnectTimer = setTimeout(() => openLogStream(), 3000);
                }
            });
            logsSocket.addEventListener('error', () => {
                appendLog('--- log stream error ---');
            });
        }

        function closeLogStream() {
            if (logsReconnectTimer) {
                clearTimeout(logsReconnectTimer);
                logsReconnectTimer = null;
            }
            if (logsSocket && logsSocket.readyState !== WebSocket.CLOSED) {
                try { logsSocket.close(); } catch (_) {}
            }
            logsSocket = null;
        }

        async function switchLLM(name, trigger, displayName) {
            if (!name) return;
            const label = displayName || name;
            if (trigger) trigger.disabled = true;
            componentsLoaded = false;
            setStatusMessage(`Switching to ${label}…`, 'info');
            try {
                const res = await fetch('/api/components/llm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name }),
                });
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const payload = await res.json();
                await refreshComponents(true);
                const activeName = payload?.active || label;
                setStatusMessage(`LLM switched to ${activeName}`, 'success');
            } catch (error) {
                console.error('[synth_webui] Unable to switch LLM', error);
                setStatusMessage('Unable to switch LLM engine', 'error');
                if (trigger) trigger.disabled = false;
            }
        }

        function renderComponentGroup(container, items, emptyLabel, options = {}) {
            if (!container) return;
            const { emphasiseActive = false } = options;
            container.innerHTML = '';
            if (!Array.isArray(items) || !items.length) {
                const empty = document.createElement('div');
                empty.className = 'meta';
                empty.textContent = `No ${emptyLabel} available.`;
                container.appendChild(empty);
                return;
            }

            const createFlag = (label, secondary = false) => {
                const flag = document.createElement('span');
                flag.className = secondary ? 'component-flag component-flag-secondary' : 'component-flag';
                flag.textContent = label;
                return flag;
            };

            items.forEach((item, index) => {
                const details = document.createElement('details');
                details.className = 'component-item';
                if (index === 0 && options.openFirst) {
                    details.open = true;
                }

                const summary = document.createElement('summary');
                const summaryMain = document.createElement('div');
                summaryMain.className = 'component-summary-main';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'component-name';
                const displayName = item?.display_name || item?.name || 'Unnamed';
                nameSpan.textContent = displayName;
                summaryMain.appendChild(nameSpan);

                const status = (item?.status || '').toString().toLowerCase();
                if (status && status !== 'unknown') {
                    const statusSpan = document.createElement('span');
                    statusSpan.className = `component-status component-status-${status}`;
                    statusSpan.textContent = status;
                    summaryMain.appendChild(statusSpan);
                }

                summary.appendChild(summaryMain);

                const summaryActions = document.createElement('div');
                summaryActions.className = 'component-summary-actions';

                if (emphasiseActive) {
                    if (item?.active) {
                        summaryActions.appendChild(createFlag('active'));
                    } else if (item?.loaded) {
                        summaryActions.appendChild(createFlag('loaded', true));
                    }
                }

                if (emphasiseActive && item?.name && !item?.active) {
                    const btn = document.createElement('button');
                    btn.className = 'pill secondary';
                    btn.type = 'button';
                    btn.textContent = 'Set as active';
                    btn.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        switchLLM(item.name, btn, displayName);
                    });
                    summaryActions.appendChild(btn);
                }

                if (summaryActions.childElementCount) {
                    summary.appendChild(summaryActions);
                }

                details.appendChild(summary);

                if (item?.description) {
                    const desc = document.createElement('p');
                    desc.className = 'component-description';
                    desc.textContent = item.description;
                    details.appendChild(desc);
                }

                // Add "Open Desktop" button for external URLs (like Selkies)
                if (item?.is_external) {
                    // For Selkies, dynamically construct URL using current hostname
                    let targetUrl = item.url;
                    if (item.name === 'selkies_desktop' && item.selkies_protocol && item.selkies_port) {
                        const currentHost = window.location.hostname;
                        targetUrl = `${item.selkies_protocol}://${currentHost}:${item.selkies_port}`;
                    }
                    
                    if (targetUrl) {
                        const openButtonWrapper = document.createElement('div');
                        openButtonWrapper.style.cssText = 'margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;';
                        
                        const openBtn = document.createElement('button');
                        openBtn.className = 'pill';
                        openBtn.type = 'button';
                        openBtn.textContent = '🖥️ Open Desktop';
                        openBtn.style.cssText = 'font-size: 1rem; padding: 0.5rem 1rem;';
                        openBtn.addEventListener('click', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            window.open(targetUrl, '_blank', 'noopener,noreferrer');
                        });
                        
                        const urlHint = document.createElement('small');
                        urlHint.style.cssText = 'color: var(--text-muted); font-size: 0.85rem;';
                        urlHint.textContent = `Opens ${targetUrl}`;
                        
                        openButtonWrapper.appendChild(openBtn);
                        openButtonWrapper.appendChild(urlHint);
                        details.appendChild(openButtonWrapper);
                    }
                }

                if (item?.details) {
                    const detailLine = document.createElement('div');
                    detailLine.className = 'component-details';
                    detailLine.textContent = item.details;
                    details.appendChild(detailLine);
                }

                if (item?.error) {
                    const errorLine = document.createElement('div');
                    errorLine.className = 'component-error';
                    errorLine.textContent = item.error;
                    details.appendChild(errorLine);
                }

                const actions = Array.isArray(item?.actions) ? item.actions : [];
                if (actions.length) {
                    const actionsWrapper = document.createElement('div');
                    actionsWrapper.className = 'component-actions';

                    const heading = document.createElement('h3');
                    heading.className = 'component-actions-heading';
                    heading.textContent = `Supported actions (${actions.length})`;
                    actionsWrapper.appendChild(heading);

                    const list = document.createElement('ul');
                    list.className = 'component-action-list';

                    actions.forEach((action) => {
                        const li = document.createElement('li');

                        const title = document.createElement('div');
                        title.className = 'component-action-title';
                        title.textContent = action?.name || 'Unnamed action';
                        li.appendChild(title);

                        if (action?.description) {
                            const actionDesc = document.createElement('div');
                            actionDesc.className = 'component-action-description';
                            actionDesc.textContent = action.description;
                            li.appendChild(actionDesc);
                        }

                        const chips = [];
                        if (Array.isArray(action?.required_fields) && action.required_fields.length) {
                            chips.push(`required: ${action.required_fields.join(', ')}`);
                        }
                        if (Array.isArray(action?.optional_fields) && action.optional_fields.length) {
                            chips.push(`optional: ${action.optional_fields.join(', ')}`);
                        }
                        if (chips.length) {
                            const meta = document.createElement('div');
                            meta.className = 'component-action-meta';
                            chips.forEach((label) => {
                                const chip = document.createElement('span');
                                chip.textContent = label;
                                meta.appendChild(chip);
                            });
                            li.appendChild(meta);
                        }

                        list.appendChild(li);
                    });

                    actionsWrapper.appendChild(list);
                    details.appendChild(actionsWrapper);
                } else {
                    const noActions = document.createElement('div');
                    noActions.className = 'meta';
                    noActions.textContent = 'No actions registered.';
                    details.appendChild(noActions);
                }

                container.appendChild(details);
            });
        }

        function renderLLM(data) {
            if (!componentsLLMSummary || !componentsLLMList) return;
            componentsLLMSummary.innerHTML = '';
            const engines = Array.isArray(data?.engines) ? data.engines : [];
            const activeInfo = engines.find((engine) => engine?.active);
            const activeDisplay = activeInfo?.display_name || data?.active || '';
            const activeLine = document.createElement('div');
            activeLine.textContent = activeDisplay ? `Active engine: ${activeDisplay}${activeInfo && activeInfo.name && activeInfo.name !== activeDisplay ? ` (${activeInfo.name})` : ''}` : 'No active engine detected';
            componentsLLMSummary.appendChild(activeLine);
            if (Array.isArray(data?.available) && data.available.length) {
                const availableNames = data.available.map((name) => {
                    const match = engines.find((engine) => engine?.name === name);
                    if (match?.display_name && match.display_name !== name) {
                        return `${match.display_name} (${name})`;
                    }
                    return name;
                });
                const availableLine = document.createElement('div');
                availableLine.textContent = `Available: ${availableNames.join(', ')}`;
                componentsLLMSummary.appendChild(availableLine);
            }
            renderComponentGroup(componentsLLMList, engines, 'LLM engines', { emphasiseActive: true, openFirst: true });
        }

        function renderComponents(data) {
            renderLLM(data.llm || {});
            const interfaces = Array.isArray(data.interfaces) ? data.interfaces : [];
            setInterfaceOptionsFromComponents(interfaces);
            renderComponentGroup(componentsInterfacesList, interfaces, 'interfaces', { openFirst: false });
            renderComponentGroup(componentsPluginsList, data.plugins || [], 'plugins', { openFirst: false });
        }

        async function refreshComponents(force = false) {
            if (componentsLoading) return;
            if (!force && componentsLoaded) return;
            if (!componentsLLMSummary || !componentsLLMList || !componentsInterfacesList || !componentsPluginsList) return;

            componentsLoading = true;
            componentsLoaded = false;

            componentsLLMSummary.textContent = 'Loading…';
            componentsLLMList.innerHTML = '';
            componentsInterfacesList.innerHTML = '<div class="meta">Loading…</div>';
            componentsPluginsList.innerHTML = '<div class="meta">Loading…</div>';

            try {
                const res = await fetch('/api/components');
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const payload = await res.json();
                renderComponents(payload || {});
                componentsLoaded = true;
                setStatusMessage('Component overview updated', 'success');
            } catch (error) {
                console.error('[synth_webui] Unable to load component overview', error);
                if (componentsLLMSummary) componentsLLMSummary.textContent = 'Unable to load component data.';
                if (componentsLLMList) componentsLLMList.innerHTML = '';
                if (componentsInterfacesList) {
                    componentsInterfacesList.innerHTML = '<div class="component-error">Unable to load interface list.</div>';
                }
                if (componentsPluginsList) {
                    componentsPluginsList.innerHTML = '<div class="component-error">Unable to load plugin list.</div>';
                }
                setStatusMessage('Unable to load component overview', 'warn');
            } finally {
                componentsLoading = false;
            }
        }

        function createPersonaTriggersGroup(triggerItems) {
            const row = document.createElement('div');
            row.className = 'config-row';
            row.style.cssText = 'border-left: 3px solid var(--primary); padding-left: 1rem;';
            
            const labelLine = document.createElement('div');
            labelLine.className = 'config-label';
            labelLine.innerHTML = '<strong>Activate Synth on:</strong>';
            labelLine.style.cssText = 'margin-bottom: 0.75rem; font-size: 1.1em;';
            row.appendChild(labelLine);
            
            const desc = document.createElement('div');
            desc.className = 'meta';
            desc.textContent = 'Select which persona attributes trigger Synth to respond';
            desc.style.cssText = 'margin-bottom: 1rem;';
            row.appendChild(desc);
            
            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.cssText = 'display: flex; flex-direction: column; gap: 0.5rem;';
            
            // Map keys to friendly labels
            const triggerLabels = {
                'PERSONA_ALIASES_TRIGGER': 'Aliases (names/nicknames)',
                'PERSONA_INTERESTS_TRIGGER': 'Interests',
                'PERSONA_LIKES_TRIGGER': 'Likes',
                'PERSONA_DISLIKES_TRIGGER': 'Dislikes'
            };
            
            // Sort by defined order
            const sortOrder = ['PERSONA_ALIASES_TRIGGER', 'PERSONA_INTERESTS_TRIGGER', 'PERSONA_LIKES_TRIGGER', 'PERSONA_DISLIKES_TRIGGER'];
            triggerItems.sort((a, b) => sortOrder.indexOf(a.key) - sortOrder.indexOf(b.key));
            
            triggerItems.forEach((item) => {
                const checkboxWrapper = document.createElement('label');
                checkboxWrapper.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; cursor: pointer;';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                // Convert string "true"/"false" to boolean, or handle boolean directly
                const currentValue = item.value === true || item.value === 'true' || item.value === 'True' || item.value === '1';
                checkbox.checked = currentValue;
                checkbox.disabled = item.env_override || !item.editable;
                checkbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer;';
                
                checkbox.addEventListener('change', async (event) => {
                    const newValue = event.target.checked;
                    console.log(`[synth_webui] Updating ${item.key} from ${currentValue} to:`, newValue);
                    
                    // Disable checkbox during update
                    const originalDisabled = checkbox.disabled;
                    checkbox.disabled = true;
                    
                    try {
                        const res = await fetch('/api/config', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ key: item.key, value: newValue })
                        });
                        
                        if (res.ok) {
                            console.log(`[synth_webui] ✓ ${item.key} updated successfully`);
                            item.value = newValue; // Update local state
                            showToast('Settings saved');
                        } else {
                            const errorText = await res.text();
                            console.error(`[synth_webui] Failed to update ${item.key}:`, res.status, errorText);
                            checkbox.checked = !newValue; // Revert
                            showToast('Failed to update trigger', true);
                        }
                    } catch (error) {
                        console.error(`[synth_webui] Error updating ${item.key}:`, error);
                        checkbox.checked = !newValue; // Revert
                        showToast('Error updating trigger', true);
                    } finally {
                        checkbox.disabled = originalDisabled;
                    }
                });
                
                const labelText = document.createElement('span');
                labelText.textContent = triggerLabels[item.key] || item.label;
                labelText.style.cssText = 'font-size: 1rem;';
                
                if (item.env_override) {
                    const overrideIcon = document.createElement('span');
                    overrideIcon.className = 'override-icon';
                    overrideIcon.textContent = ' ⚠️';
                    overrideIcon.title = 'Overridden by environment variable';
                    labelText.appendChild(overrideIcon);
                }
                
                checkboxWrapper.appendChild(checkbox);
                checkboxWrapper.appendChild(labelText);
                checkboxContainer.appendChild(checkboxWrapper);
            });
            
            row.appendChild(checkboxContainer);
            return row;
        }

        function createConfigRow(item) {
            if (!item) return null;
            const row = document.createElement('div');
            row.className = 'config-row';

            const labelLine = document.createElement('div');
            labelLine.className = 'config-label-line';
            const label = document.createElement('span');
            label.textContent = item.label || item.key;
            labelLine.appendChild(label);

            if (item.env_override) {
                const icon = document.createElement('span');
                icon.className = 'override-icon';
                icon.textContent = '⚠️';
                icon.title = 'This value is overridden by an environment variable';
                labelLine.appendChild(icon);
            }
            row.appendChild(labelLine);

            if (item.component && item.component !== 'core' && item.component_label) {
                const sub = document.createElement('div');
                sub.className = 'config-label-sub';
                sub.textContent = item.component_label;
                row.appendChild(sub);
            }

            const inputWrapper = document.createElement('div');
            inputWrapper.className = 'config-input';
            let input;
            const type = item.value_type || 'str';
            
            // Special case: dropdown for choices constraint
            if (item.constraints && item.constraints.choices && Array.isArray(item.constraints.choices)) {
                const choices = item.constraints.choices;
                
                // If too many choices (>50), use datalist for searchable combobox
                if (choices.length > 50) {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.list = `datalist-${item.key}`;
                    input.style.cssText = 'padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #666; background: #1a1a1a; color: #fff; width: 100%;';
                    if (item.value !== undefined && item.value !== null) {
                        input.value = String(item.value);
                    }
                    
                    const datalist = document.createElement('datalist');
                    datalist.id = `datalist-${item.key}`;
                    choices.forEach(choice => {
                        const option = document.createElement('option');
                        option.value = choice;
                        datalist.appendChild(option);
                    });
                    
                    // For TZ, add validation to ensure only valid timezones
                    if (item.key === 'TZ') {
                        const validationMsg = document.createElement('div');
                        validationMsg.style.cssText = 'color: #dc2626; font-size: 0.85rem; margin-top: 0.25rem; display: none;';
                        validationMsg.textContent = '⚠️ Please select a valid timezone from the list';
                        
                        input.addEventListener('input', () => {
                            const isValid = choices.includes(input.value);
                            if (!isValid && input.value) {
                                validationMsg.style.display = 'block';
                                input.style.borderColor = '#dc2626';
                            } else {
                                validationMsg.style.display = 'none';
                                input.style.borderColor = '#666';
                            }
                        });
                        
                        inputWrapper.appendChild(input);
                        inputWrapper.appendChild(datalist);
                        inputWrapper.appendChild(validationMsg);
                    } else {
                        inputWrapper.appendChild(input);
                        inputWrapper.appendChild(datalist);
                    }
                    
                } else {
                    // Regular dropdown for smaller lists
                    input = document.createElement('select');
                    input.style.cssText = 'padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #666; background: #1a1a1a; color: #fff;';
                    
                    choices.forEach(choice => {
                        const option = document.createElement('option');
                        option.value = choice;
                        option.textContent = choice;
                        if (String(item.value) === String(choice)) {
                            option.selected = true;
                        }
                        input.appendChild(option);
                    });
                    
                    inputWrapper.appendChild(input);
                }
                
            } else if (item.key === 'TRAINER_IDS') {
                // Special case: key-value list editor for TRAINER_IDS
                const listContainer = document.createElement('div');
                listContainer.style.cssText = 'display: flex; flex-direction: column; gap: 0.5rem;';
                const parseEntriesFromValue = () => {
                    const currentValue = String(item.value || '');
                    if (!currentValue.trim()) return [];
                    return currentValue.split(',')
                        .map((token) => {
                            const [iface, id] = token.split(':');
                            return {
                                interface: (iface || '').trim(),
                                id: (id || '').trim(),
                            };
                        })
                        .filter((entry) => entry.interface || entry.id);
                };

                let trainerEntries = parseEntriesFromValue();

                const persistTrainerEntries = async () => {
                    if (item.env_override || !item.editable) {
                        return;
                    }
                    const serialized = trainerEntries
                        .filter((entry) => entry.interface && entry.id)
                        .map((entry) => `${entry.interface}:${entry.id}`)
                        .join(',');
                    try {
                        const res = await fetch('/api/config', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ key: item.key, value: serialized }),
                        });
                        if (!res.ok) {
                            showToast('Failed to update trainer IDs', true);
                            return;
                        }
                        item.value = serialized;
                        showToast('Settings saved');
                    } catch (error) {
                        console.error('[synth_webui] Error updating TRAINER_IDS:', error);
                        showToast('Error updating trainer IDs', true);
                    }
                };

                const createInterfaceSelect = (entry) => {
                    const select = document.createElement('select');
                    select.style.cssText = 'flex: 1; padding: 0.45rem; border-radius: 0.35rem; border: 1px solid #666; background: #1a1a1a; color: #fff;';
                    select.disabled = item.env_override || !item.editable;

                    const addOption = (value, label, disabled = false) => {
                        const option = document.createElement('option');
                        option.value = value;
                        option.textContent = label;
                        option.disabled = disabled;
                        select.appendChild(option);
                        return option;
                    };

                    const placeholder = document.createElement('option');
                    placeholder.value = '';
                    placeholder.textContent = 'Select interface';
                    placeholder.disabled = true;
                    placeholder.hidden = true;
                    if (!entry.interface) {
                        placeholder.selected = true;
                    }
                    select.appendChild(placeholder);

                    const knownNames = (interfaceOptions || []).map((iface) => iface.name);
                    (interfaceOptions || []).forEach((iface) => {
                        addOption(iface.name, iface.displayName || iface.name, false);
                    });

                    if (entry.interface && !knownNames.includes(entry.interface)) {
                        addOption(entry.interface, `${entry.interface} (inactive)`, false);
                    }

                    select.value = entry.interface || '';

                    select.addEventListener('change', async () => {
                        entry.interface = select.value;
                        await persistTrainerEntries();
                    });

                    return select;
                };

                const renderEntries = () => {
                    listContainer.innerHTML = '';

                    // Ensure trainerEntries reflects latest saved value in case env changed
                    const savedEntries = parseEntriesFromValue();
                    if (savedEntries.length && !trainerEntries.length) {
                        trainerEntries = savedEntries;
                    }

                    trainerEntries.forEach((entry, index) => {
                        const entryRow = document.createElement('div');
                        entryRow.style.cssText = 'display: flex; gap: 0.5rem; align-items: center;';

                        const interfaceSelect = createInterfaceSelect(entry);

                        const separator = document.createElement('span');
                        separator.textContent = ':';
                        separator.style.cssText = 'color: var(--text-soft);';

                        const idInput = document.createElement('input');
                        idInput.type = 'text';
                        idInput.placeholder = 'id';
                        idInput.value = entry.id || '';
                        idInput.style.cssText = 'flex: 1; padding: 0.45rem; border-radius: 0.35rem; border: 1px solid #666; background: #1a1a1a; color: #fff;';
                        idInput.disabled = item.env_override || !item.editable;

                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = '−';
                        removeBtn.type = 'button';
                        removeBtn.style.cssText = 'padding: 0.4rem 0.7rem; border-radius: 0.35rem; border: 1px solid #dc2626; background: rgba(220, 38, 38, 0.1); color: #dc2626; cursor: pointer; font-weight: bold; transition: all 0.2s ease;';
                        removeBtn.disabled = item.env_override || !item.editable;
                        removeBtn.onmouseenter = () => { if (!removeBtn.disabled) removeBtn.style.background = 'rgba(220, 38, 38, 0.25)'; };
                        removeBtn.onmouseleave = () => { removeBtn.style.background = 'rgba(220, 38, 38, 0.1)'; };

                        removeBtn.addEventListener('click', async () => {
                            trainerEntries.splice(index, 1);
                            await persistTrainerEntries();
                            renderEntries();
                        });

                        const handleSave = async () => {
                            entry.id = idInput.value.trim();
                            await persistTrainerEntries();
                        };

                        idInput.addEventListener('blur', handleSave);
                        idInput.addEventListener('keydown', (event) => {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                handleSave();
                            }
                        });

                        entryRow.appendChild(interfaceSelect);
                        entryRow.appendChild(separator);
                        entryRow.appendChild(idInput);
                        entryRow.appendChild(removeBtn);
                        listContainer.appendChild(entryRow);
                    });

                    const addRow = document.createElement('div');
                    addRow.style.cssText = 'display: flex; gap: 0.5rem; align-items: center;';

                    const addBtn = document.createElement('button');
                    addBtn.textContent = '+ Add Trainer ID';
                    addBtn.type = 'button';
                    addBtn.style.cssText = 'padding: 0.5rem 1rem; border-radius: 0.35rem; border: 1px solid var(--primary); background: rgba(255, 107, 214, 0.1); color: var(--primary); cursor: pointer; font-weight: 600; transition: all 0.2s ease;';
                    addBtn.disabled = item.env_override || !item.editable;
                    addBtn.onmouseenter = () => { if (!addBtn.disabled) addBtn.style.background = 'rgba(255, 107, 214, 0.25)'; };
                    addBtn.onmouseleave = () => { addBtn.style.background = 'rgba(255, 107, 214, 0.1)'; };

                    addBtn.addEventListener('click', () => {
                        if (addBtn.disabled) return;
                        const existingBlank = trainerEntries.find((entry) => !entry.interface || !entry.id);
                        if (existingBlank) {
                            const blankIndex = trainerEntries.indexOf(existingBlank);
                            const rows = listContainer.querySelectorAll('div');
                            const targetRow = rows[blankIndex];
                            if (targetRow) {
                                const select = targetRow.querySelector('select');
                                if (select) select.focus();
                            }
                            return;
                        }
                        trainerEntries.push({ interface: '', id: '' });
                        renderEntries();
                        requestAnimationFrame(() => {
                            const rows = listContainer.querySelectorAll('div');
                            const lastRow = rows[rows.length - 1];
                            if (lastRow) {
                                const select = lastRow.querySelector('select');
                                if (select) select.focus();
                            }
                        });
                    });

                    addRow.appendChild(addBtn);
                    listContainer.appendChild(addRow);
                };

                renderEntries();
                inputWrapper.appendChild(listContainer);
                input = listContainer; // Set input reference for later logic
                
            } else if (item.key === 'REACT_WHEN_MENTIONED') {
                const emojiContainer = document.createElement('div');
                emojiContainer.style.cssText = 'display: flex; flex-direction: column; gap: 0.5rem;';
                
                input = document.createElement('input');
                input.type = 'text';
                input.maxLength = 2; // Most emojis are 1-2 characters
                input.style.cssText = 'font-size: 2rem; text-align: center; width: 5rem;';
                input.dataset.emojiField = 'true';
                input.disabled = item.env_override || !item.editable;
                if (item.value !== undefined && item.value !== null) {
                    input.value = String(item.value);
                } else {
                    input.value = '';
                }
                if (item.default !== undefined && item.default !== null) {
                    input.placeholder = String(item.default);
                }
                input.addEventListener('click', (event) => {
                    event.preventDefault();
                    showEmojiPicker(input, event);
                });
                input.addEventListener('focus', () => {
                    showEmojiPicker(input);
                });
                
                const warning = document.createElement('small');
                warning.style.cssText = 'color: #ff9800; font-size: 0.85rem;';
                warning.textContent = '⚠️ Some interfaces or servers/channels may not support all emojis as reactions';
                
                emojiContainer.appendChild(input);
                emojiContainer.appendChild(warning);
                inputWrapper.appendChild(emojiContainer);
                
            } else if (type === 'bool') {
                // Create toggle switch for boolean values
                input = document.createElement('input');
                input.type = 'checkbox';
                input.checked = !!item.value;
                input.id = `toggle-${item.key}`;
                
                const toggleSwitch = document.createElement('label');
                toggleSwitch.className = 'toggle-switch';
                toggleSwitch.htmlFor = input.id;
                
                const toggleSlider = document.createElement('span');
                toggleSlider.className = 'toggle-slider';
                
                toggleSwitch.appendChild(toggleSlider);
                inputWrapper.appendChild(input);
                inputWrapper.appendChild(toggleSwitch);
            } else {
                input = document.createElement('input');
                if (type === 'int' || type === 'float') {
                    input.type = 'number';
                } else {
                    input.type = item.sensitive ? 'password' : 'text';
                }
                if (item.value !== undefined && item.value !== null) {
                    input.value = String(item.value);
                } else {
                    input.value = '';
                }
                if (item.default !== undefined && item.default !== null) {
                    input.placeholder = String(item.default);
                }
            }

            input.dataset.key = item.key;
            input.dataset.type = type;
            input.dataset.label = item.label || item.key;

            if (!item.editable) {
                input.disabled = true;
                if (type === 'bool') {
                    // Disable the toggle switch visually
                    const toggleSwitch = inputWrapper.querySelector('.toggle-switch');
                    if (toggleSwitch) {
                        toggleSwitch.style.pointerEvents = 'none';
                        toggleSwitch.style.opacity = '0.5';
                    }
                }
            }

            const applyUpdate = () => {
                if (!item.editable) return;
                let newValue;
                if (type === 'bool') {
                    newValue = input.checked;
                    if (!!item.value === newValue) return;
                } else if (type === 'int') {
                    const parsed = parseInt(input.value, 10);
                    if (Number.isNaN(parsed)) {
                        setStatusMessage(`Invalid integer for ${item.label || item.key}`, 'warn');
                        input.value = item.value !== undefined && item.value !== null ? String(item.value) : '';
                        return;
                    }
                    if (item.value !== undefined && Number(item.value) === parsed) return;
                    newValue = parsed;
                } else if (type === 'float') {
                    const parsed = parseFloat(input.value);
                    if (Number.isNaN(parsed)) {
                        setStatusMessage(`Invalid number for ${item.label || item.key}`, 'warn');
                        input.value = item.value !== undefined && item.value !== null ? String(item.value) : '';
                        return;
                    }
                    if (item.value !== undefined && Number(item.value) === parsed) return;
                    newValue = parsed;
                } else {
                    newValue = input.value;
                    const current = item.value !== undefined && item.value !== null ? String(item.value) : '';
                    if (current === newValue) return;
                    
                    // Validate timezone if TZ field with choices constraint
                    if (item.key === 'TZ' && item.constraints && item.constraints.choices) {
                        if (!item.constraints.choices.includes(newValue)) {
                            showToast('Please select a valid timezone from the list', true);
                            input.value = current; // Revert to old value
                            return;
                        }
                    }
                }
                updateConfigValue(item, newValue, input);
            };

            // Skip event listeners for TRAINER_IDS (handles saving internally)
            if (item.key === 'TRAINER_IDS') {
                // Do nothing, TRAINER_IDS handles its own save logic
            } else if (type === 'bool') {
                input.addEventListener('change', applyUpdate);
            } else if (item.key === 'REACT_WHEN_MENTIONED') {
                input.addEventListener('change', applyUpdate);
                input.addEventListener('blur', applyUpdate);
            } else {
                input.addEventListener('change', applyUpdate);
                input.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        applyUpdate();
                    }
                });
            }

            // Append input to wrapper only if not already done (choices dropdown, TRAINER_IDS list, emoji selector, or bool toggle)
            const alreadyAppended = (item.constraints && item.constraints.choices) || item.key === 'TRAINER_IDS' || item.key === 'REACT_WHEN_MENTIONED' || type === 'bool';
            if (!alreadyAppended) {
                inputWrapper.appendChild(input);
            }
            row.appendChild(inputWrapper);

            if (item.description) {
                const description = document.createElement('div');
                description.className = 'config-description';
                description.textContent = item.description;
                row.appendChild(description);
            }
            
            // Add LogChat info text for LOGGING_LOGCHAT_LEVEL
            if (item.key === 'LOGGING_LOGCHAT_LEVEL') {
                const logchatInfo = document.createElement('div');
                logchatInfo.className = 'config-description';
                logchatInfo.id = 'logchat-info-text';
                logchatInfo.style.cssText = 'margin-top: 0.5rem; font-style: italic; color: var(--meta);';
                logchatInfo.textContent = 'Loading LogChat status...';
                row.appendChild(logchatInfo);
                
                // Fetch LogChat info
                fetch('/api/logchat/info')
                    .then(res => res.json())
                    .then(data => {
                        const infoEl = document.getElementById('logchat-info-text');
                        if (!infoEl) return;
                        if (data.configured) {
                            infoEl.textContent = `✓ LogChat configured: ${data.interface} chat ${data.chat_id}`;
                            infoEl.style.color = 'var(--ok)';
                        } else {
                            infoEl.textContent = '✗ No LogChat set. Use /logchat command in a chat to configure.';
                            infoEl.style.color = 'var(--warn)';
                        }
                    })
                    .catch(() => {
                        const infoEl = document.getElementById('logchat-info-text');
                        if (infoEl) {
                            infoEl.textContent = '✗ Unable to check LogChat status';
                            infoEl.style.color = 'var(--warn)';
                        }
                    });
            }

            return row;
        }

        async function updateConfigValue(item, value, input) {
            if (!input) return;
            const originalDisabled = input.disabled;
            input.disabled = true;
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: item.key, value }),
                });
                if (!response.ok) {
                    const detail = await response.json().catch(() => ({}));
                    throw new Error(detail?.detail || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                // Update item value immediately
                item.value = value;
                
                // Check if component reload is required
                if (result.requires_reload) {
                    showToast(`⚠️ ${result.message || 'Configuration updated. Component reload required.'}`, false, 8000);
                    console.warn(`[synth_webui] Component '${result.component}' requires reload after config change`);
                } else {
                    // Show success toast
                    showToast('Settings saved');
                }
                
                // No need to refresh entire config, just update this item
                configLoaded = false;
            } catch (error) {
                console.error('[synth_webui] Unable to update configuration', error);
                showToast(`Failed to update ${item.label || item.key}`, true);
                
                // Revert to old value on error
                if (item.value_type === 'bool') {
                    input.checked = !!item.value;
                } else {
                    input.value = item.value !== undefined && item.value !== null ? String(item.value) : '';
                }
            } finally {
                if (!item.env_override) {
                    input.disabled = originalDisabled;
                } else {
                    input.disabled = true;
                }
            }
        }

        function renderConfig(data) {
            if (!configGeneralList || !configAdvancedList) return;
            hideEmojiPicker();
            configGeneralList.innerHTML = '';
            configAdvancedList.innerHTML = '';

            const items = Array.isArray(data?.items) ? data.items : [];
            
            // Filter out items tagged with "logs_only" (should only appear in Logs tab)
            const filteredItems = items.filter(item => {
                if (!item || typeof item !== 'object') return false;
                if (item.key === 'LOGGING_LOGCHAT_LEVEL') {
                    return false;
                }
                const tags = item.tags || [];
                return !tags.includes('logs_only');
            });
            
            // Separate PERSONA_*_TRIGGER items for grouped rendering
            const personaTriggers = [];
            const otherItems = [];
            
            filteredItems.forEach((item) => {
                if (item.key && item.key.match(/^PERSONA_(ALIASES|INTERESTS|LIKES|DISLIKES)_TRIGGER$/)) {
                    personaTriggers.push(item);
                } else {
                    otherItems.push(item);
                }
            });
            
            // Render grouped persona triggers first (if any)
            if (personaTriggers.length > 0) {
                const groupedRow = createPersonaTriggersGroup(personaTriggers);
                if (groupedRow) {
                    configGeneralList.appendChild(groupedRow);
                }
            }
            
            // Group other items by component for better organization
            const groupedByComponent = {};
            otherItems.forEach((item) => {
                const componentName = item.component || 'core';
                const componentLabel = item.component_label || componentName;
                if (!groupedByComponent[componentName]) {
                    groupedByComponent[componentName] = {
                        label: componentLabel,
                        items: []
                    };
                }
                groupedByComponent[componentName].items.push(item);
            });
            
            // Render items grouped by component with headers
            Object.entries(groupedByComponent).forEach(([componentName, group]) => {
                const target = group.items.some(i => i.advanced) ? configAdvancedList : configGeneralList;
                
                // Only show header if component is not 'core' or if there are multiple components
                const showHeader = componentName !== 'core' || Object.keys(groupedByComponent).length > 1;
                
                if (showHeader && group.items.length > 0) {
                    const header = document.createElement('h3');
                    header.textContent = group.label.toUpperCase();
                    header.style.cssText = 'margin-top: 1.5rem; margin-bottom: 0.75rem; font-size: 1.1rem; font-weight: 700; color: var(--primary); letter-spacing: 0.05em;';
                    target.appendChild(header);
                }
                
                group.items.forEach((item) => {
                    const itemTarget = item.advanced ? configAdvancedList : configGeneralList;
                    const row = createConfigRow(item);
                    if (row && itemTarget) {
                        itemTarget.appendChild(row);
                    }
                });
            });

            if (!configGeneralList.childElementCount) {
                configGeneralList.innerHTML = '<div class="meta">No configurable settings available.</div>';
            }
            if (!configAdvancedList.childElementCount) {
                configAdvancedList.innerHTML = '<div class="meta">No advanced settings defined.</div>';
            }

            if (configDisclaimer && data?.messages?.env_override) {
                configDisclaimer.innerHTML = `<span class="override-icon">⚠️</span> ${data.messages.env_override}`;
            }
            if (configAdvancedWarning && data?.messages?.advanced_warning) {
                configAdvancedWarning.textContent = data.messages.advanced_warning;
            }
        }

        async function refreshConfig(force = false) {
            if (configLoading) return;
            if (configLoaded && !force) return;
            if (!configGeneralList || !configAdvancedList) return;

            if (!interfaceOptions.length) {
                await ensureInterfaceOptions();
            }

            configLoading = true;
            try {
                const response = await fetch('/api/config');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const payload = await response.json();
                renderConfig(payload);
                configLoaded = true;
            } catch (error) {
                console.error('[synth_webui] Unable to load configuration', error);
                setStatusMessage('Unable to load configuration', 'warn');
                if (configGeneralList) {
                    configGeneralList.innerHTML = '<div class="component-error">Unable to load configuration data.</div>';
                }
                if (configAdvancedList) {
                    configAdvancedList.innerHTML = '';
                }
            } finally {
                configLoading = false;
            }
        }

        logsRefreshBtn?.addEventListener('click', () => {
            closeLogStream();
            openLogStream();
        });

        // Chat toggle button handler
        let chatVisible = true;
        chatToggleBtn?.addEventListener('click', () => {
            chatVisible = !chatVisible;
            if (chatPanel) {
                if (chatVisible) {
                    chatPanel.classList.remove('hidden');
                    chatToggleBtn.textContent = '💬';
                    chatToggleBtn.setAttribute('aria-label', 'Hide chat');
                    chatToggleBtn.setAttribute('title', 'Hide Chat');
                } else {
                    chatPanel.classList.add('hidden');
                    chatToggleBtn.textContent = '👁️';
                    chatToggleBtn.setAttribute('aria-label', 'Show chat');
                    chatToggleBtn.setAttribute('title', 'Show Chat');
                }
            }
        });

        // WebUI Log Level dropdown handler
        const webuiLogLevelSelect = document.getElementById('webui-log-level');
        if (webuiLogLevelSelect) {
            // Load current value from config
            fetch('/api/config')
                .then(res => res.json())
                .then(data => {
                    const webuiLogLevel = data.items.find(item => item.key === 'WEBUI_LOG_LEVEL');
                    if (webuiLogLevel && webuiLogLevel.value) {
                        webuiLogLevelSelect.value = webuiLogLevel.value.toLowerCase();
                    }
                })
                .catch(err => console.error('[synth_webui] Failed to load WEBUI_LOG_LEVEL:', err));
            
            // Save when changed
            webuiLogLevelSelect.addEventListener('change', async (event) => {
                const newLevel = event.target.value;
                console.log('[synth_webui] Changing WEBUI_LOG_LEVEL to:', newLevel);
                
                const originalDisabled = webuiLogLevelSelect.disabled;
                webuiLogLevelSelect.disabled = true;
                
                try {
                    const res = await fetch('/api/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ key: 'WEBUI_LOG_LEVEL', value: newLevel })
                    });
                    
                    if (res.ok) {
                        console.log('[synth_webui] ✓ WEBUI_LOG_LEVEL updated successfully');
                        showToast('Settings saved');
                    } else {
                        console.error('[synth_webui] Failed to update WEBUI_LOG_LEVEL:', res.status);
                        showToast('Failed to update log level', true);
                    }
                } catch (error) {
                    console.error('[synth_webui] Error updating WEBUI_LOG_LEVEL:', error);
                    showToast('Error updating log level', true);
                } finally {
                    webuiLogLevelSelect.disabled = originalDisabled;
                }
            });
        }

        // LogChat Notification Level dropdown handler
        const logchatLevelSelect = document.getElementById('logchat-level');
        if (logchatLevelSelect) {
            // Load current value from config
            fetch('/api/config')
                .then(res => res.json())
                .then(data => {
                    const logchatLevel = data.items.find(item => item.key === 'LOGGING_LOGCHAT_LEVEL');
                    if (logchatLevel && logchatLevel.value) {
                        logchatLevelSelect.value = logchatLevel.value.toUpperCase();
                    }
                })
                .catch(err => console.error('[synth_webui] Failed to load LOGGING_LOGCHAT_LEVEL:', err));
            
            // Save when changed
            logchatLevelSelect.addEventListener('change', async (event) => {
                const newLevel = String(event.target.value || '').toUpperCase();
                event.target.value = newLevel;
                console.log('[synth_webui] Changing LOGGING_LOGCHAT_LEVEL to:', newLevel);
                
                const originalDisabled = logchatLevelSelect.disabled;
                logchatLevelSelect.disabled = true;
                
                try {
                    const res = await fetch('/api/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ key: 'LOGGING_LOGCHAT_LEVEL', value: newLevel })
                    });
                    
                    if (res.ok) {
                        console.log('[synth_webui] ✓ LOGGING_LOGCHAT_LEVEL updated successfully');
                        showToast('Settings saved');
                    } else {
                        console.error('[synth_webui] Failed to update LOGGING_LOGCHAT_LEVEL:', res.status);
                        showToast('Failed to update LogChat level', true);
                    }
                } catch (error) {
                    console.error('[synth_webui] Error updating LOGGING_LOGCHAT_LEVEL:', error);
                    showToast('Error updating LogChat level', true);
                } finally {
                    logchatLevelSelect.disabled = originalDisabled;
                }
            });
        }

        function formatUptime(seconds) {
            if (Number.isNaN(seconds) || seconds < 0) return '--';
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const parts = [];
            if (hrs) parts.push(`${hrs}h`);
            if (mins || hrs) parts.push(`${mins}m`);
            parts.push(`${secs}s`);
            return parts.join(' ');
        }

        async function refreshStats(silent = false) {
            try {
                const res = await fetch('/stats');
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                if (uptimeEl) uptimeEl.textContent = formatUptime(Number(data.uptime || 0));
                if (sessionsEl) sessionsEl.textContent = Number(data.sessions || 0);
                if (!silent) setStatusMessage('Statistics updated', 'success');
            } catch (error) {
                if (!silent) setStatusMessage('Unable to fetch statistics', 'warn');
            }
        }

        function persistHistory() {
            try {
                if (!historyBuffer.length) {
                    localStorage.removeItem(HISTORY_KEY);
                    return;
                }
                localStorage.setItem(HISTORY_KEY, JSON.stringify(historyBuffer));
            } catch (error) {
                console.debug('[synth_webui] Unable to persist history', error);
            }
        }

        function restoreHistory() {
            try {
                const stored = localStorage.getItem(HISTORY_KEY);
                if (!stored) return;
                const parsed = JSON.parse(stored);
                if (!Array.isArray(parsed)) return;
                historyBuffer = parsed.slice(-HISTORY_LIMIT);
                historyBuffer.forEach(({ sender, text }) => addMessage(sender || 'rekku', text || '', false));
            } catch (error) {
                console.debug('[synth_webui] Unable to restore history', error);
            }
        }

        function ensureAudioContext(allowResume = false) {
            if (audioContext) {
                if (allowResume && audioContext.state === 'suspended') audioContext.resume();
                return;
            }
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (error) {
                console.debug('[synth_webui] Unable to create AudioContext', error);
            }
        }

        function playChime() {
            if (!audioContext) return;
            try {
                ensureAudioContext(true);
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start(now);
                osc.stop(now + 0.6);
            } catch (error) {
                console.debug('[synth_webui] Unable to play chime', error);
            }
        }

        function updateNotifyUI(enabled, silent = false) {
            notificationsEnabled = enabled && IS_SECURE;
            if (notifyToggle) notifyToggle.checked = notificationsEnabled;
            if (notifyStatus) {
                if (!IS_SECURE) {
                    notifyStatus.textContent = 'HTTPS or localhost required';
                } else {
                    notifyStatus.textContent = notificationsEnabled ? 'Enabled' : 'Disabled';
                }
            }
            localStorage.setItem(NOTIFY_KEY, notificationsEnabled ? '1' : '0');
            if (!silent) {
                const tone = notificationsEnabled ? 'success' : 'info';
                const message = notificationsEnabled ? 'Desktop notifications enabled' : 'Desktop notifications disabled';
                setStatusMessage(message, tone);
            }
        }

        function requestNotifications() {
            if (!IS_SECURE) {
                setStatusMessage('Notifications require HTTPS or localhost', 'warn');
                updateNotifyUI(false, true);
                return;
            }
            if (!('Notification' in window)) {
                setStatusMessage('This browser does not support desktop notifications', 'warn');
                updateNotifyUI(false, true);
                return;
            }
            Notification.requestPermission().then((permission) => {
                if (permission === 'granted') {
                    updateNotifyUI(true);
                } else {
                    updateNotifyUI(false, true);
                    setStatusMessage('Notifications blocked by the browser', 'warn');
                }
            }).catch(() => {
                updateNotifyUI(false, true);
                setStatusMessage('Unable to request notification permission', 'error');
            });
        }

        notifyToggle?.addEventListener('change', (event) => {
            if (event.target.checked) {
                ensureAudioContext(true);
                requestNotifications();
            } else {
                updateNotifyUI(false);
            }
        });

        (function bootstrapNotifications() {
            const saved = localStorage.getItem(NOTIFY_KEY) === '1';
            if (!IS_SECURE) {
                updateNotifyUI(false, true);
                return;
            }
            if (saved && 'Notification' in window && Notification.permission === 'granted') {
                updateNotifyUI(true, true);
            } else {
                updateNotifyUI(false, true);
            }
        })();

        function handleIncoming(text) {
            if (!notificationsEnabled) return;
            playChime();
            if (document.hidden && 'Notification' in window && Notification.permission === 'granted') {
                try {
                    const note = new Notification('New message', {
                        body: text,
                        tag: 'synth-webui-chat',
                        icon: '%%LOGO_URL%%'
                    });
                    setTimeout(() => note.close(), 5000);
                } catch (error) {
                    console.debug('[synth_webui] Notification error', error);
                }
            }
        }

        function addMessage(sender, text, persist = true) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble ' + (sender === 'rekku' ? 'rekku' : 'user');
            bubble.textContent = text;
            messages.appendChild(bubble);
            messages.scrollTop = messages.scrollHeight;

            if (sender === 'rekku') {
                handleIncoming(text);
            }

            if (persist) {
                historyBuffer.push({ sender, text });
                if (historyBuffer.length > HISTORY_LIMIT) {
                    historyBuffer = historyBuffer.slice(-HISTORY_LIMIT);
                }
                persistHistory();
            }
        }

        function addTypingIndicator() {
            if (typingIndicator) return; // Avoid duplicates
            
            typingIndicator = document.createElement('div');
            typingIndicator.className = 'bubble rekku typing-indicator';
            typingIndicator.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
            messages.appendChild(typingIndicator);
            messages.scrollTop = messages.scrollHeight;
            
            // Clear any existing timeout
            if (typingTimeoutTimer) {
                clearTimeout(typingTimeoutTimer);
            }
            
            // Fetch RESPONSE_TIMEOUT from server config (default to 240 seconds = 240000ms)
            // We add 5 seconds buffer to account for network delays
            const timeoutMs = (window.RESPONSE_TIMEOUT || 240) * 1000 + 5000;
            
            // Set timeout to show error message if no response arrives
            typingTimeoutTimer = setTimeout(() => {
                removeTypingIndicator();
                // Fetch FAILED_MESSAGE_TEXT from server config (default to "😵")
                const failedMessage = window.FAILED_MESSAGE_TEXT || "😵";
                addMessage('rekku', failedMessage);
                showToast('Response timeout - LLM did not respond in time', true);
            }, timeoutMs);
        }

        function removeTypingIndicator() {
            if (typingIndicator) {
                typingIndicator.remove();
                typingIndicator = null;
            }
            if (typingTimeoutTimer) {
                clearTimeout(typingTimeoutTimer);
                typingTimeoutTimer = null;
            }
        }

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            setStatusMessage('Connecting…', 'info');
            ws = new WebSocket(`${protocol}://${window.location.host}/ws`);

            ws.addEventListener('open', () => {
                statusLabel.textContent = 'Connected';
                statusIndicator?.classList.add('online');
                sendBtn.disabled = false;
                setStatusMessage('Connection established.', 'success');
                refreshStats(true);
            });

            ws.addEventListener('message', (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'session') {
                    sessionId = data.session_id;
                    refreshStats(true);
                    return;
                }
                if (data.type === 'message') {
                    removeTypingIndicator(); // Remove typing indicator before showing actual message
                    const sender = data.sender || 'rekku';
                    addMessage(sender, data.text || '');
                }
            });

            ws.addEventListener('close', () => {
                statusLabel.textContent = 'Disconnected';
                statusIndicator?.classList.remove('online');
                setStatusMessage('Connection lost. Reconnecting…', 'warn');
                sendBtn.disabled = true;
                setTimeout(connect, 1500);
            });

            ws.addEventListener('error', () => {
                setStatusMessage('Communication error.', 'error');
            });
        }

        form.addEventListener('submit', (event) => {
            event.preventDefault();
            const text = input.value.trim();
            if (!text || !ws || ws.readyState !== WebSocket.OPEN) {
                return;
            }
            addMessage('user', text);
            addTypingIndicator(); // Show typing indicator immediately after sending
            ws.send(JSON.stringify({ text }));
            input.value = '';
        });

        input.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                form.dispatchEvent(new Event('submit'));
            }
        });

        window.addEventListener('beforeunload', () => {
            try { if (ws) ws.close(); } catch (_) {}
            closeLogStream();
        });

        restoreHistory();
        activateTab(activeTab, true);
        connect();
        refreshStats(true);
        setInterval(() => refreshStats(true), 15000);
    </script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { VRM, VRMLoaderPlugin, VRMUtils } from 'https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.js';
        import { loadMixamoAnimation } from '/static/js/loadMixamoAnimation.js';
        import { mixamoVRMRigMap } from '/static/js/mixamoVRMRigMap.js';

        const canvas = document.getElementById('vrm-canvas');
        if (!canvas) {
            console.error('[synth_webui] VRM canvas not found in DOM');
        } else {
            console.log('[synth_webui] VRM canvas found, initializing viewer...');
            const setStatus = window.SynthWebUISetStatus || ((message) => console.log('[synth_webui]', message));
            const listEl = document.getElementById('vrm-list');
            const uploadInput = document.getElementById('vrm-upload');
            const refreshBtn = document.getElementById('vrm-refresh');
            let currentModel = null;
            let currentVRM = null;
            let currentMixer = null;
            let currentAnimation = null;
            let idleAction = null;
            let talkingAction = null;
            let thinkingAction = null; // Placeholder for future
            let isProcessing = false;
            let isSpeaking = false;

            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setPixelRatio(window.devicePixelRatio);
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(30, canvas.clientWidth / Math.max(1, canvas.clientHeight), 0.1, 20);
            camera.position.set(0, 1.4, 2.2);

            const controls = new OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.enablePan = false;
            controls.target.set(0, 1.2, 0);
            controls.update();

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
            keyLight.position.set(1, 1.2, 1);
            scene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-1, 1.2, -1);
            scene.add(fillLight);

            // Add floor/ground plane to always show 3D room
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, 
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);
            console.log('[synth_webui] Floor plane added to scene');

            // Add grid helper for better depth perception
            const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x333333);
            gridHelper.position.y = 0.001; // Slightly above floor to avoid z-fighting
            scene.add(gridHelper);
            console.log('[synth_webui] Grid helper added to scene');

            const loader = new GLTFLoader();
            loader.setCrossOrigin('anonymous');
            loader.setResourcePath('/avatars/');
            loader.register((parser) => new VRMLoaderPlugin(parser));
            console.log('[synth_webui] VRM loader configured with resource path: /avatars/');

            const blobLoader = new GLTFLoader();
            blobLoader.setCrossOrigin('anonymous');
            blobLoader.register((parser) => new VRMLoaderPlugin(parser));
            console.log('[synth_webui] Blob loader configured');

            const clock = new THREE.Clock();

            function resizeRenderer() {
                const width = canvas.clientWidth;
                const height = canvas.clientHeight || 1;
                if (canvas.width !== width || canvas.height !== height) {
                    renderer.setSize(width, height, false);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
            }
            window.addEventListener('resize', resizeRenderer);
            resizeRenderer();

            function clearVRM() {
                console.log('[synth_webui] Clearing current VRM from scene');
                if (currentVRM) {
                    scene.remove(currentVRM.scene);
                    currentVRM = null;
                    console.log('[synth_webui] VRM cleared successfully');
                }
            }

            async function loadVRM(url, name, { isObjectUrl = false } = {}) {
                console.log(`[synth_webui] ========== LOAD VRM START ==========`);
                console.log(`[synth_webui] loadVRM called - url: ${url}, name: ${name}, isObjectUrl: ${isObjectUrl}`);
                console.log(`[synth_webui] typeof url: ${typeof url}`);
                console.log(`[synth_webui] url length: ${url ? url.length : 'N/A'}`);
                console.log(`[synth_webui] Current location: ${window.location.href}`);
                
                if (!url) {
                    console.warn('[synth_webui] ⚠️ No URL provided for VRM, clearing');
                    clearVRM();
                    currentModel = null;
                    setStatus('No active avatar', 'warn');
                    console.log(`[synth_webui] ========== LOAD VRM END (no url) ==========`);
                    return;
                }
                
                try {
                    const targetLoader = isObjectUrl ? blobLoader : loader;
                    console.log(`[synth_webui] Using loader: ${isObjectUrl ? 'blobLoader' : 'loader'}`);
                    console.log(`[synth_webui] Loader object:`, targetLoader);
                    
                    const cacheBusted = isObjectUrl ? url : (url.includes('?') ? `${url}&t=${Date.now()}` : `${url}?t=${Date.now()}`);
                    console.log(`[synth_webui] Original URL: ${url}`);
                    console.log(`[synth_webui] Cache-busted URL: ${cacheBusted}`);
                    console.log(`[synth_webui] Attempting to fetch VRM from: ${cacheBusted}`);
                    
                    // Test fetch before loading
                    if (!isObjectUrl) {
                        console.log(`[synth_webui] Pre-testing fetch to verify URL accessibility...`);
                        try {
                            const testResponse = await fetch(cacheBusted, { method: 'HEAD' });
                            console.log(`[synth_webui] ✓ HEAD request status: ${testResponse.status}`);
                            console.log(`[synth_webui] HEAD response headers:`, [...testResponse.headers.entries()]);
                            console.log(`[synth_webui] Content-Type: ${testResponse.headers.get('content-type')}`);
                            console.log(`[synth_webui] Content-Length: ${testResponse.headers.get('content-length')}`);
                        } catch (fetchErr) {
                            console.error(`[synth_webui] ⚠️ HEAD request failed:`, fetchErr);
                            console.error(`[synth_webui] This indicates the URL is not accessible`);
                        }
                    }
                    
                    setStatus(`Loading avatar ${name}…`, 'info');
                    console.log(`[synth_webui] Calling targetLoader.loadAsync()...`);
                    
                    const gltf = await targetLoader.loadAsync(cacheBusted);
                    
                    console.log('[synth_webui] ✓ GLTF loaded successfully');
                    console.log('[synth_webui] GLTF object:', gltf);
                    console.log('[synth_webui] GLTF.userData:', gltf.userData);
                    console.log('[synth_webui] GLTF.scene:', gltf.scene);
                    console.log('[synth_webui] GLTF.userData.vrm:', gltf.userData.vrm);
                    
                    const vrm = gltf.userData.vrm || await VRM.from(gltf);
                    console.log('[synth_webui] ✓ VRM object created');
                    console.log('[synth_webui] VRM object:', vrm);
                    console.log('[synth_webui] VRM.scene:', vrm?.scene);
                    console.log('[synth_webui] VRM.meta:', vrm?.meta);
                    
                    if (vrm && vrm.scene) {
                        console.log('[synth_webui] Processing VRM scene...');
                        console.log('[synth_webui] Scene children count:', vrm.scene.children.length);
                        
                        console.log('[synth_webui] Removing unnecessary joints...');
                        VRMUtils.removeUnnecessaryJoints(vrm.scene);
                        console.log('[synth_webui] ✓ Unnecessary joints removed');
                        
                        console.log('[synth_webui] Removing unnecessary vertices...');
                        VRMUtils.removeUnnecessaryVertices(vrm.scene);
                        console.log('[synth_webui] ✓ Unnecessary vertices removed');
                        
                        if (vrm.meta?.metaVersion === '0') {
                            console.log('[synth_webui] Rotating VRM0 model (metaVersion=0)');
                            VRMUtils.rotateVRM0(vrm);
                            console.log('[synth_webui] ✓ VRM0 rotation applied');
                        } else {
                            console.log('[synth_webui] No VRM0 rotation needed (metaVersion:', vrm.meta?.metaVersion, ')');
                        }
                        
                        console.log('[synth_webui] Setting scene rotation and position...');
                        vrm.scene.rotation.y = Math.PI;
                        vrm.scene.position.set(0, 0, 0);
                        console.log('[synth_webui] Scene rotation:', vrm.scene.rotation);
                        console.log('[synth_webui] Scene position:', vrm.scene.position);
                        
                        console.log('[synth_webui] Disabling frustum culling for all objects...');
                        let objectCount = 0;
                        vrm.scene.traverse((obj) => {
                            obj.frustumCulled = false;
                            objectCount++;
                        });
                        console.log('[synth_webui] ✓ Frustum culling disabled for', objectCount, 'objects');
                        
                        console.log('[synth_webui] ✓ VRM scene processed successfully');
                    } else {
                        console.error('[synth_webui] ⚠️ VRM or VRM.scene is missing!');
                    }
                    
                    console.log('[synth_webui] Clearing existing VRM from scene...');
                    clearVRM();
                    console.log('[synth_webui] ✓ Previous VRM cleared');
                    
                    console.log('[synth_webui] Adding new VRM to scene...');
                    console.log('[synth_webui] Scene before add - children count:', scene.children.length);
                    scene.add(vrm.scene);
                    console.log('[synth_webui] ✓ VRM added to scene');
                    console.log('[synth_webui] Scene after add - children count:', scene.children.length);
                    
                    currentVRM = vrm;
                    currentModel = name;
                    console.log('[synth_webui] currentVRM set:', currentVRM);
                    console.log('[synth_webui] currentModel set:', currentModel);
                    
                    // Initialize animation mixer
                    console.log('[synth_webui] Creating AnimationMixer...');
                    currentMixer = new THREE.AnimationMixer(vrm.scene);
                    
                    // Load default animations
                    console.log('[synth_webui] Loading default animations...');
                    await loadDefaultAnimations(vrm);
                    
                    setStatus(`Avatar ${name} loaded`, 'success');
                    console.log(`[synth_webui] ✓✓✓ VRM ${name} loaded and rendered successfully ✓✓✓`);
                    console.log(`[synth_webui] ========== LOAD VRM END (success) ==========`);
                    
                } catch (error) {
                    console.error('[synth_webui] ========== LOAD VRM ERROR ==========');
                    console.error('[synth_webui] ⚠️ Failed to load VRM');
                    console.error('[synth_webui] Error object:', error);
                    console.error('[synth_webui] Error message:', error.message);
                    console.error('[synth_webui] Error name:', error.name);
                    console.error('[synth_webui] Error stack:', error.stack);
                    
                    if (error.response) {
                        console.error('[synth_webui] HTTP Response:', error.response);
                    }
                    
                    setStatus('Unable to load the VRM model', 'error');
                    console.error('[synth_webui] ========== LOAD VRM END (error) ==========');
                }
            }

            // Animation loading function
            async function loadDefaultAnimations(vrm) {
                try {
                    console.log('[synth_webui] Loading idle animation (happy_idle.fbx)...');
                    const idleClip = await loadMixamoAnimation('/static/animations/happy_idle.fbx', vrm);
                    idleAction = currentMixer.clipAction(idleClip);
                    idleAction.play();
                    console.log('[synth_webui] ✓ Idle animation loaded and playing');
                    
                    console.log('[synth_webui] Loading talking animation (talking.fbx)...');
                    const talkingClip = await loadMixamoAnimation('/static/animations/talking.fbx', vrm);
                    talkingAction = currentMixer.clipAction(talkingClip);
                    talkingAction.setLoop(THREE.LoopRepeat);
                    console.log('[synth_webui] ✓ Talking animation loaded');
                    
                    // Placeholder for thinking animation (will be added when available)
                    thinkingAction = null;
                    console.log('[synth_webui] Thinking animation: placeholder (not yet available)');
                    
                } catch (error) {
                    console.error('[synth_webui] Failed to load animations:', error);
                }
            }

            // Start thinking animation (placeholder)
            function startThinking() {
                if (!currentMixer || !idleAction || isProcessing) return;
                isProcessing = true;
                console.log('[synth_webui] 🤔 Thinking state active (placeholder - using idle for now)');
                // When thinking animation is available, crossfade to it here
                // For now, keep idle running
            }

            // Stop thinking animation
            function stopThinking() {
                isProcessing = false;
                console.log('[synth_webui] ✓ Thinking state ended');
            }

            // Start talking animation with estimated duration
            function startTalking(text) {
                if (!currentMixer || !talkingAction || !idleAction) return;
                
                // Estimate speech duration (approximately 150 words per minute)
                const wordCount = text.trim().split(/\s+/).length;
                const estimatedDuration = (wordCount / 150) * 60; // seconds
                
                console.log(`[synth_webui] 💬 Starting talking animation for ${wordCount} words (~${estimatedDuration.toFixed(1)}s)`);
                
                isSpeaking = true;
                
                // Crossfade from idle to talking
                idleAction.fadeOut(0.5);
                talkingAction.reset().fadeIn(0.5).play();
                
                // Stop talking after estimated duration
                setTimeout(() => {
                    stopTalking();
                }, estimatedDuration * 1000);
            }

            // Stop talking animation
            function stopTalking() {
                if (!currentMixer || !talkingAction || !idleAction || !isSpeaking) return;
                
                console.log('[synth_webui] ✓ Stopping talking animation');
                isSpeaking = false;
                
                // Crossfade from talking back to idle
                talkingAction.fadeOut(0.5);
                idleAction.reset().fadeIn(0.5).play();
            }

            function render() {
                requestAnimationFrame(render);
                const delta = clock.getDelta();
                if (currentVRM) currentVRM.update(delta);
                if (currentMixer) currentMixer.update(delta);
                controls.update();
                resizeRenderer();
                renderer.render(scene, camera);
            }
            render();

            // Expose animation functions globally for message chain integration
            window.VRMAnimations = {
                startThinking,
                stopThinking,
                startTalking,
                stopTalking
            };
            console.log('[synth_webui] Animation functions exposed globally via window.VRMAnimations');

            function renderList(data) {
                if (!listEl) return;
                listEl.innerHTML = '';
                if (!data.models.length) {
                    const li = document.createElement('li');
                    li.className = 'empty';
                    li.textContent = 'No models available';
                    listEl.appendChild(li);
                    clearVRM();
                    currentModel = null;
                    return;
                }
                data.models.forEach((model) => {
                    const li = document.createElement('li');
                    if (model.active) li.classList.add('active');
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'name';
                    nameSpan.textContent = model.name;
                    const actions = document.createElement('div');
                    actions.className = 'vrm-actions';

                    const activate = document.createElement('button');
                    activate.textContent = model.active ? 'Active' : 'Activate';
                    if (!model.active) {
                        activate.addEventListener('click', () => setActive(model.name));
                    } else {
                        activate.disabled = true;
                    }

                    const remove = document.createElement('button');
                    remove.textContent = 'Delete';
                    remove.addEventListener('click', () => removeModel(model.name));

                    actions.appendChild(activate);
                    actions.appendChild(remove);
                    li.appendChild(nameSpan);
                    li.appendChild(actions);
                    listEl.appendChild(li);
                });
            }

            async function refreshModels(feedback = false) {
                console.log('[synth_webui] ========== REFRESH MODELS START ==========');
                console.log('[synth_webui] Refreshing VRM models list... (feedback:', feedback, ')');
                
                try {
                    console.log('[synth_webui] Fetching /api/vrm...');
                    const res = await fetch('/api/vrm');
                    console.log(`[synth_webui] Fetch /api/vrm response status: ${res.status}`);
                    console.log(`[synth_webui] Response ok: ${res.ok}`);
                    console.log(`[synth_webui] Response headers:`, [...res.headers.entries()]);
                    
                    if (!res.ok) {
                        console.error('[synth_webui] ⚠️ Non-OK response from /api/vrm');
                        throw new Error('HTTP ' + res.status);
                    }
                    
                    console.log('[synth_webui] Parsing JSON response...');
                    const data = await res.json();
                    console.log('[synth_webui] ✓ VRM models data:', data);
                    console.log('[synth_webui] Models count:', data.models ? data.models.length : 0);
                    
                    if (data.models) {
                        data.models.forEach((model, idx) => {
                            console.log(`[synth_webui] Model ${idx}:`, model);
                        });
                    }
                    
                    console.log('[synth_webui] Rendering models list...');
                    renderList(data);
                    console.log('[synth_webui] ✓ List rendered');
                    
                    const activeModel = data.models.find((item) => item.active);
                    console.log('[synth_webui] Active model from server:', activeModel);
                    console.log('[synth_webui] Current model in UI:', currentModel);
                    
                    if (activeModel && activeModel.name !== currentModel) {
                        console.log(`[synth_webui] Active model changed! Loading: ${activeModel.name}`);
                        console.log(`[synth_webui] Active model URL: ${activeModel.url}`);
                        await loadVRM(activeModel.url, activeModel.name);
                    } else if (!activeModel) {
                        console.log('[synth_webui] No active model on server, clearing VRM');
                        clearVRM();
                        if (feedback) setStatus('No active avatar', 'warn');
                    } else if (feedback) {
                        console.log('[synth_webui] Active model unchanged, no reload needed');
                        setStatus('Avatar list refreshed', 'success');
                    }
                    
                    console.log('[synth_webui] ========== REFRESH MODELS END (success) ==========');
                    
                } catch (error) {
                    console.error('[synth_webui] ========== REFRESH MODELS ERROR ==========');
                    console.error('[synth_webui] ⚠️ Unable to refresh models');
                    console.error('[synth_webui] Error:', error);
                    console.error('[synth_webui] Error stack:', error.stack);
                    setStatus('Unable to refresh avatar list', 'error');
                    console.error('[synth_webui] ========== REFRESH MODELS END (error) ==========');
                }
            }

            async function setActive(name) {
                console.log('[synth_webui] ========== SET ACTIVE VRM START ==========');
                console.log('[synth_webui] Setting active VRM to:', name);
                
                try {
                    console.log('[synth_webui] Posting to /api/vrm/active...');
                    const res = await fetch('/api/vrm/active', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name }),
                    });
                    
                    console.log('[synth_webui] Set active response status:', res.status);
                    console.log('[synth_webui] Set active response ok:', res.ok);
                    
                    if (!res.ok) {
                        console.error('[synth_webui] ⚠️ Set active failed with status:', res.status);
                        throw new Error('HTTP ' + res.status);
                    }
                    
                    console.log('[synth_webui] ✓ Active VRM set successfully, refreshing...');
                    await refreshModels(true);
                    console.log('[synth_webui] ========== SET ACTIVE VRM END (success) ==========');
                    
                } catch (error) {
                    console.error('[synth_webui] ========== SET ACTIVE VRM ERROR ==========');
                    console.error('[synth_webui] ⚠️ Failed to set active VRM');
                    console.error('[synth_webui] Error:', error);
                    console.error('[synth_webui] Error stack:', error.stack);
                    setStatus('Unable to activate the model', 'error');
                    console.error('[synth_webui] ========== SET ACTIVE VRM END (error) ==========');
                }
            }

            async function removeModel(name) {
                console.log('[synth_webui] ========== REMOVE VRM START ==========');
                console.log('[synth_webui] Attempting to remove VRM:', name);
                
                if (!confirm(`Delete the model "${name}"?`)) {
                    console.log('[synth_webui] User cancelled deletion');
                    console.log('[synth_webui] ========== REMOVE VRM END (cancelled) ==========');
                    return;
                }
                
                console.log('[synth_webui] User confirmed deletion');
                
                try {
                    const encodedName = encodeURIComponent(name);
                    console.log('[synth_webui] Encoded name:', encodedName);
                    console.log('[synth_webui] Deleting via DELETE /api/vrm/' + encodedName);
                    
                    const res = await fetch(`/api/vrm/${encodedName}`, {
                        method: 'DELETE',
                    });
                    
                    console.log('[synth_webui] Delete response status:', res.status);
                    console.log('[synth_webui] Delete response ok:', res.ok);
                    
                    if (!res.ok) {
                        console.error('[synth_webui] ⚠️ Delete failed with status:', res.status);
                        throw new Error('HTTP ' + res.status);
                    }
                    
                    console.log('[synth_webui] ✓ VRM deleted successfully, refreshing...');
                    await refreshModels(true);
                    console.log('[synth_webui] ========== REMOVE VRM END (success) ==========');
                    
                } catch (error) {
                    console.error('[synth_webui] ========== REMOVE VRM ERROR ==========');
                    console.error('[synth_webui] ⚠️ Failed to delete VRM');
                    console.error('[synth_webui] Error:', error);
                    console.error('[synth_webui] Error stack:', error.stack);
                    setStatus('Unable to delete the model', 'error');
                    console.error('[synth_webui] ========== REMOVE VRM END (error) ==========');
                }
            }

            uploadInput?.addEventListener('change', async (event) => {
                console.log('[synth_webui] ========== UPLOAD VRM START ==========');
                console.log('[synth_webui] Upload input changed');
                
                const file = event.target.files?.[0];
                console.log('[synth_webui] File selected:', file);
                console.log('[synth_webui] File name:', file?.name);
                console.log('[synth_webui] File size:', file?.size, 'bytes');
                console.log('[synth_webui] File type:', file?.type);
                
                if (!file) {
                    console.warn('[synth_webui] ⚠️ No file selected');
                    console.log('[synth_webui] ========== UPLOAD VRM END (no file) ==========');
                    return;
                }
                
                if (!file.name.toLowerCase().endsWith('.vrm')) {
                    console.warn('[synth_webui] ⚠️ Invalid file extension:', file.name);
                    setStatus('Select a valid .vrm file', 'warn');
                    uploadInput.value = '';
                    console.log('[synth_webui] ========== UPLOAD VRM END (invalid extension) ==========');
                    return;
                }
                
                console.log('[synth_webui] ✓ File validation passed');
                console.log('[synth_webui] Creating FormData...');
                const formData = new FormData();
                formData.append('file', file);
                console.log('[synth_webui] ✓ FormData created');
                
                setStatus('Uploading model…', 'info');
                console.log('[synth_webui] Uploading to /api/vrm via POST...');
                
                try {
                    const res = await fetch('/api/vrm', {
                        method: 'POST',
                        body: formData,
                    });
                    
                    console.log('[synth_webui] Upload response status:', res.status);
                    console.log('[synth_webui] Upload response ok:', res.ok);
                    console.log('[synth_webui] Upload response headers:', [...res.headers.entries()]);
                    
                    if (!res.ok) {
                        console.error('[synth_webui] ⚠️ Upload failed with status:', res.status);
                        const errorText = await res.text();
                        console.error('[synth_webui] Error response body:', errorText);
                        throw new Error('HTTP ' + res.status);
                    }
                    
                    console.log('[synth_webui] ✓ Upload successful, parsing response...');
                    const payload = await res.json();
                    console.log('[synth_webui] Upload response payload:', payload);
                    console.log('[synth_webui] Uploaded model name:', payload.name);
                    console.log('[synth_webui] Uploaded model URL:', payload.url);
                    
                    console.log('[synth_webui] Creating object URL from file for immediate display...');
                    const localUrl = URL.createObjectURL(file);
                    console.log('[synth_webui] Object URL created:', localUrl);
                    
                    console.log('[synth_webui] Loading VRM from object URL...');
                    await loadVRM(localUrl, payload.name, { isObjectUrl: true });
                    
                    console.log('[synth_webui] Revoking object URL...');
                    URL.revokeObjectURL(localUrl);
                    console.log('[synth_webui] ✓ Object URL revoked');
                    
                    setStatus('Model uploaded successfully', 'success');
                    uploadInput.value = '';
                    
                    console.log('[synth_webui] Refreshing models list after upload...');
                    await refreshModels();
                    console.log('[synth_webui] ✓✓✓ Upload complete and models refreshed ✓✓✓');
                    console.log('[synth_webui] ========== UPLOAD VRM END (success) ==========');
                    
                } catch (error) {
                    console.error('[synth_webui] ========== UPLOAD VRM ERROR ==========');
                    console.error('[synth_webui] ⚠️ Upload failed');
                    console.error('[synth_webui] Error:', error);
                    console.error('[synth_webui] Error message:', error.message);
                    console.error('[synth_webui] Error stack:', error.stack);
                    setStatus('Unable to upload the model', 'error');
                    console.error('[synth_webui] ========== UPLOAD VRM END (error) ==========');
                }
            });

            refreshBtn?.addEventListener('click', () => {
                refreshModels(true);
            });

            refreshModels().catch((error) => console.error(error));
            refreshConfig().catch((error) => console.error(error));
        }
    </script>
</body>
</html>

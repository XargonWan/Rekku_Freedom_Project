# core/action_parser.py
"""Execute actions generated by Rekku."""

import asyncio
import importlib
import inspect
import os
from collections import deque
from types import SimpleNamespace
from datetime import datetime
from typing import Any, Dict, List, Tuple

import core.plugin_instance as plugin_instance
from core.logging_utils import log_debug, log_info, log_warning, log_error


# Supporto per tipi di azione
SUPPORTED_TYPES = {"message", "event", "command", "memory"}


def _validate_message_payload(payload: dict, errors: List[str]) -> None:
    """Validate payload for message actions."""
    text = payload.get("text")
    if not isinstance(text, str) or not text:
        errors.append("payload.text must be a non-empty string")

    scope = payload.get("scope")
    if scope not in {"local", "global"}:
        errors.append("payload.scope must be 'local' or 'global'")

    privacy = payload.get("privacy")
    if privacy not in {"default", "private", "public"}:
        errors.append(
            "payload.privacy must be one of ['default', 'private', 'public']"
        )

    target = payload.get("target")
    if target is not None:
        if not isinstance(target, dict):
            errors.append("payload.target must be a dict with chat_id and message_id")
        else:
            chat_id = target.get("chat_id")
            message_id = target.get("message_id")
            if not isinstance(chat_id, int):
                errors.append("payload.target.chat_id must be an int")
            if not isinstance(message_id, int):
                errors.append("payload.target.message_id must be an int")


def _validate_event_payload(payload: dict, errors: List[str]) -> None:
    """Validate payload for event actions."""
    name = payload.get("name")
    if not isinstance(name, str) or not name:
        errors.append("payload.name must be a non-empty string for event action")

    parameters = payload.get("parameters")
    if parameters is not None and not isinstance(parameters, dict):
        errors.append("payload.parameters must be a dict if provided")


def _validate_command_payload(payload: dict, errors: List[str]) -> None:
    """Validate payload for command actions."""
    name = payload.get("name")
    if not isinstance(name, str) or not name:
        errors.append("payload.name must be a non-empty string for command action")

    args = payload.get("args")
    if args is not None and not isinstance(args, list):
        errors.append("payload.args must be a list if provided")


def _validate_memory_payload(payload: dict, errors: List[str]) -> None:
    """Validate payload for memory actions."""
    content = payload.get("content")
    if not isinstance(content, str) or not content:
        errors.append("payload.content must be a non-empty string")

    tags = payload.get("tags")
    if tags is not None:
        if (
            not isinstance(tags, list)
            or not all(isinstance(tag, str) for tag in tags)
        ):
            errors.append("payload.tags must be a list of strings if provided")


def validate_action(action: dict) -> Tuple[bool, List[str]]:
    """Validate an action dictionary.

    Parameters
    ----------
    action : dict
        Dictionary describing an action.

    Returns
    -------
    tuple[bool, list[str]]
        A tuple containing a boolean validity flag and a list of error messages.
    """

    errors: List[str] = []

    if not isinstance(action, dict):
        return False, ["action must be a dict"]

    action_type = action.get("type")
    if not action_type:
        errors.append("Missing 'type'")
    elif action_type not in SUPPORTED_TYPES:
        errors.append(f"Unsupported type '{action_type}'")

    payload = action.get("payload")
    if payload is None:
        errors.append("Missing 'payload'")
    elif not isinstance(payload, dict):
        errors.append("'payload' must be a dict")

    if isinstance(payload, dict) and action_type in SUPPORTED_TYPES:
        if action_type == "message":
            _validate_message_payload(payload, errors)
        elif action_type == "event":
            _validate_event_payload(payload, errors)
        elif action_type == "command":
            _validate_command_payload(payload, errors)
        elif action_type == "memory":
            _validate_memory_payload(payload, errors)

    return len(errors) == 0, errors


# Cache for discovered action plugins
_ACTION_PLUGINS: List[Any] | None = None


def _load_action_plugins() -> List[Any]:
    """Load classes under plugins/ that implement get_supported_actions."""
    global _ACTION_PLUGINS
    if _ACTION_PLUGINS is not None:
        return _ACTION_PLUGINS

    _ACTION_PLUGINS = []
    base_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "plugins")
    for root, _dirs, files in os.walk(base_path):
        for file in files:
            if not file.endswith(".py") or file.startswith("__"):
                continue
            rel = os.path.relpath(os.path.join(root, file), os.path.dirname(os.path.dirname(__file__)))
            module_name = rel[:-3].replace(os.sep, ".")
            try:
                module = importlib.import_module(module_name)
            except Exception as e:
                log_error(f"[action_parser] Failed to import {module_name}: {e}")
                continue
            log_debug(f"[action_parser] Checking module: {module_name}")
            for _name, obj in inspect.getmembers(module, inspect.isclass):
                if hasattr(obj, "get_supported_actions"):
                    try:
                        instance = obj()
                        log_debug(f"[action_parser] Loaded plugin: {obj.__name__}")
                    except Exception as e:
                        log_error(f"[action_parser] Failed to init {obj}: {e}")
                        continue
                    _ACTION_PLUGINS.append(instance)
    return _ACTION_PLUGINS


def _plugins_for(action_type: str) -> List[Any]:
    plugins = []
    for plugin in _load_action_plugins():
        try:
            supported = plugin.get_supported_actions()
            if action_type in supported:
                plugins.append(plugin)
        except Exception as e:
            log_error(f"[action_parser] Error querying plugin {plugin}: {e}")
    return plugins


def set_available_plugins(interfaces, llm_engine, plugins):
    """Set available plugins and their details for the action parser."""
    global ACTIVE_INTERFACES, ACTIVE_LLM_ENGINE, AVAILABLE_PLUGINS

    # Set active interfaces
    ACTIVE_INTERFACES = set(interfaces)
    log_info("[action_parser] Active interfaces set.")

    # Set active LLM engine
    ACTIVE_LLM_ENGINE = llm_engine
    log_info(f"[action_parser] Active LLM engine: {ACTIVE_LLM_ENGINE}")

    # Set available plugins
    AVAILABLE_PLUGINS = plugins
    log_info("[action_parser] Available plugins set.")


# Variables to store the state
ACTIVE_INTERFACES = set()
ACTIVE_LLM_ENGINE = None
AVAILABLE_PLUGINS = []


async def _handle_message_action(action: Dict[str, Any], context: Dict[str, Any], bot, original_message):
    payload = action.get("payload", {})
    text = payload.get("text", "")
    log_debug(f"[action_parser] Handling message action: {text}")

    # Usa ACTIVE_INTERFACES direttamente
    if not ACTIVE_INTERFACES:
        log_error("[action_parser] No active interfaces to handle the message.")
        return

    # Route the message to all active interfaces
    for interface in ACTIVE_INTERFACES:
        if interface == "telegram_bot":
            from interface.telegram_bot import TelegramInterface

            telegram_bot = TelegramInterface(api_id=None, api_hash=None, bot_token=None)  # Replace with actual credentials
            await telegram_bot.send_message(original_message.chat_id, text)
        elif interface == "telegram_userbot":
            from interface.telethon_userbot import client

            await client.send_message(original_message.chat_id, text)
        elif interface == "discord":
            # Add Discord interface handling here if applicable
            log_debug("[action_parser] Discord interface handling not implemented.")
        else:
            log_error(f"[action_parser] Unsupported interface: {interface}")


async def _handle_plugin_action(action: Dict[str, Any], context: Dict[str, Any], bot, original_message):
    action_type = action.get("type")
    for plugin in _plugins_for(action_type):
        if hasattr(plugin, "execute_action"):
            try:
                result = plugin.execute_action(action, context, bot, original_message)
                if inspect.iscoroutine(result):
                    await result
            except Exception as e:
                log_error(f"[action_parser] Error executing {action_type} with {plugin}: {e}")
        else:
            log_warning(f"[action_parser] Plugin {plugin} has no execute_action()")
    if not _plugins_for(action_type):
        log_warning(f"[action_parser] No plugin supports action type '{action_type}'")


async def run_action(action: Any, context: Dict[str, Any], bot, original_message):
    """Validate and execute a single action or list of actions."""
    if isinstance(action, list):
        for act in action:
            await run_action(act, context, bot, original_message)
        return

    valid, errors = validate_action(action)
    if not valid:
        log_warning(f"[action_parser] Invalid action: {errors}")
        return

    action_type = action.get("type")

    if action_type == "message":
        await _handle_message_action(action, context, bot, original_message)
    else:
        await _handle_plugin_action(action, context, bot, original_message)


async def run_actions(actions: Any, context: Dict[str, Any], bot, original_message):
    """Execute multiple actions in sequence.

    If ``actions`` is a single dict, it will be wrapped in a list.
    Invalid actions are logged and skipped.
    """
    if actions is None:
        return

    if isinstance(actions, dict):
        actions = [actions]
    elif not isinstance(actions, list):
        log_error("[action_parser] run_actions expects a list or dict")
        return

    for idx, action in enumerate(actions):
        try:
            valid, errors = validate_action(action)
            if not valid:
                log_warning(f"[action_parser] Skipping invalid action {idx}: {errors}")
                continue
            log_debug(f"[action_parser] Running action {idx}: {action.get('type')}")
            await run_action(action, context, bot, original_message)
        except Exception as e:
            log_error(f"[action_parser] Error executing action {idx}: {e}")


async def parse_action(action: dict, bot, message):
    """Parse and execute a single action."""
    log_debug(f"[action_parser] Received action: {action}")

    action_type = action.get("type")
    interface = action.get("interface")
    payload = action.get("payload")

    if not action_type or not interface or not payload:
        log_warning("[action_parser] Invalid action structure: missing type, interface, or payload")
        return

    log_debug(f"[action_parser] Action type: {action_type}, Interface: {interface}, Payload: {payload}")

    if action_type == "message":
        target = payload.get("target")
        text = payload.get("text")
        thread_id = payload.get("thread_id")

        if not text:
            log_warning("[action_parser] Invalid message action: missing text")
            return

        # If target is missing or invalid, use the original message's chat_id as fallback
        if not target:
            target = getattr(message, "chat_id", None)
            log_debug(f"[action_parser] No target specified, using original chat_id: {target}")

        # If thread_id is missing but original message has one, use it as fallback
        if not thread_id and hasattr(message, "chat_id"):
            original_thread_id = getattr(message, "message_thread_id", None)
            if original_thread_id:
                thread_id = original_thread_id
                log_debug(f"[action_parser] No thread_id specified, using original thread_id: {thread_id}")

        # Additional validation for target
        if not target:
            log_warning("[action_parser] No valid target found, cannot send message")
            return

        try:
            log_debug(f"[action_parser] Sending message to {target} (thread_id: {thread_id}) with text: {text}")

            # Prepare kwargs for send_message
            send_kwargs = {"chat_id": target, "text": text}
            if thread_id:
                send_kwargs["message_thread_id"] = thread_id

            await bot.send_message(**send_kwargs)
            log_debug(f"[action_parser] Message successfully sent to {target} (thread: {thread_id})")
        except Exception as e:
            log_error(f"[action_parser] Failed to send message to {target} (thread: {thread_id}): {e}")
            # Try fallback to original chat if target was different
            if hasattr(message, "chat_id") and target != message.chat_id:
                try:
                    fallback_thread_id = getattr(message, "message_thread_id", None)
                    fallback_kwargs = {"chat_id": message.chat_id, "text": text}
                    if fallback_thread_id:
                        fallback_kwargs["message_thread_id"] = fallback_thread_id

                    log_debug(f"[action_parser] Retrying with original chat_id: {message.chat_id} (thread: {fallback_thread_id})")
                    await bot.send_message(**fallback_kwargs)
                    log_debug(f"[action_parser] Message successfully sent to fallback chat: {message.chat_id} (thread: {fallback_thread_id})")
                except Exception as fallback_error:
                    log_error(f"[action_parser] Fallback also failed: {fallback_error}")
    else:
        plugin = getattr(plugin_instance, "plugin", None)
        if plugin and hasattr(plugin, "get_supported_action_types") and hasattr(
            plugin, "handle_custom_action"
        ):
            try:
                supported = plugin.get_supported_action_types() or []
            except Exception as e:
                log_warning(
                    f"[action_parser] Failed to query plugin action types: {e}"
                )
                supported = []

            if action_type in supported:
                try:
                    await plugin.handle_custom_action(action_type, payload)
                except Exception as e:
                    log_error(
                        f"[action_parser] Error delegating {action_type} to plugin: {e}"
                    )
                return

        log_warning(
            f"[action_parser] Unsupported action type: {action_type} â€” no plugin handler found"
        )


def initialize_core(notify_fn=None):
    """Initialize and log all core components."""
    from core.core_initializer import core_initializer
    return core_initializer.initialize_all(notify_fn=notify_fn)


__all__ = ["run_action", "run_actions", "parse_action", "validate_action", "initialize_core"]

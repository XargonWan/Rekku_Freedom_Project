# core/action_parser.py
"""Execute actions generated by Rekku."""

import asyncio
import inspect
import os
import json
import time
from collections import deque
from types import SimpleNamespace
from datetime import datetime
from typing import Any, Dict, List, Tuple, Optional

from core.logging_utils import log_debug, log_info, log_warning, log_error
from core.prompt_engine import build_full_json_instructions
from core.validation_registry import get_validation_registry
from core.config_manager import config_registry

# Import RESTRICT_ACTIONS from image_processor (already registered there)
from core.image_processor import RESTRICT_ACTIONS

# Global dictionary to track retry attempts per chat/message thread for the corrector
CORRECTOR_RETRIES = config_registry.get_value(
    "CORRECTOR_RETRIES",
    2,
    value_type="int",
    label="JSON Corrector Retries",
    description="Number of times the corrector retries invalid JSON responses from LLM",
    group="core",
    component="core",
)

def _update_corrector_retries(value: int | None) -> None:
    """Update global CORRECTOR_RETRIES variable."""
    global CORRECTOR_RETRIES
    CORRECTOR_RETRIES = int(value) if value is not None else 2

config_registry.add_listener("CORRECTOR_RETRIES", _update_corrector_retries)

_retry_tracker = {}


def _extract_json_local(text: str):
    """Local helper to extract JSON from text using transport_layer's extract_json_from_text.
    
    Returns:
        Parsed JSON object or None if not found
    """
    from core.transport_layer import extract_json_from_text
    return extract_json_from_text(text, return_metadata=False)


ERROR_RETRY_POLICY = {
    "description": (
        "If you receive a system_message of type 'error' with the phrase 'Please repeat your "
        "previous message, not this very prompt, but your previous reply, corrected. If that was a "
        "web search please use the content to reply with your own words.' you must automatically "
        "re-send the exact same JSON you sent previously, but with the part indicated as invalid corrected."
    ),
    "steps": [
        "1. Identify which part of your last sent JSON caused the error (e.g. an unsupported action type or missing parameter).",
        "2. Create a new JSON that is identical to the one you previously sent, except for correcting ONLY the invalid part.",
        "3. Do not add, remove or reorder any other actions or payload content.",
        "4. Re-submit the corrected JSON immediately (without waiting for user instructions).",
    ],
}


def _get_retry_key(message):
    """Generate a unique key for tracking retries based on chat/thread.

    Preserve chat_id and thread_id as strings (no numeric coercion),
    since external interfaces may represent identifiers as strings. This
    ensures consistent retry keys without changing original identifier types.
    """
    chat_id = getattr(message, "chat_id", None)
    thread_id = getattr(message, "thread_id", None)

    def _norm(value):
        if value is None:
            return "none"
        # Keep original representation as string (don't coerce to int)
        return str(value)

    return f"{_norm(chat_id)}_{_norm(thread_id)}"


def _should_retry(message, max_retries: int = CORRECTOR_RETRIES) -> bool:
    """Check if we should attempt retry for this message context."""
    retry_key = _get_retry_key(message)
    current_time = time.time()

    # Clean up old retry entries (older than 5 minutes)
    cutoff_time = current_time - 300  # 5 minutes
    keys_to_remove = [k for k, (count, timestamp) in _retry_tracker.items() if timestamp < cutoff_time]
    for key in keys_to_remove:
        del _retry_tracker[key]

    # Check current retry count
    retry_count, _ = _retry_tracker.get(retry_key, (0, current_time))
    return retry_count < max_retries


def _increment_retry(message):
    """Increment retry count for this message context."""
    retry_key = _get_retry_key(message)
    current_time = time.time()
    retry_count, _ = _retry_tracker.get(retry_key, (0, current_time))
    _retry_tracker[retry_key] = (retry_count + 1, current_time)
    return retry_count + 1


# Legacy corrector removed
# NOTE: The legacy `corrector(errors, failed_actions, bot, message)` implementation
# has been intentionally removed to prevent accidental invocation. Use the centralized
# `corrector_orchestrator` in this module (or `core.message_chain.handle_incoming_message`)
# for correction/orchestration flows. If any callers still reference `corrector`,
# update them to the new orchestrator or the message chain.


# Cache for interface actions discovered via the interface registry
_INTERFACE_ACTIONS: Dict[str, str] | None = None


def _load_interface_actions() -> Dict[str, str]:
    """Return a mapping of action_type -> interface_name from registered interfaces."""
    global _INTERFACE_ACTIONS

    if _INTERFACE_ACTIONS is not None:
        log_debug(
            f"[action_parser] ðŸ”„ Returning cached interface actions ({len(_INTERFACE_ACTIONS)})"
        )
        return _INTERFACE_ACTIONS

    try:
        from core.core_initializer import INTERFACE_REGISTRY
    except Exception as e:  # pragma: no cover - registry unavailable
        log_warning(f"[action_parser] Unable to access INTERFACE_REGISTRY: {e}")
        INTERFACE_REGISTRY = {}

    actions: Dict[str, str] = {}
    for name, iface in INTERFACE_REGISTRY.items():
        try:
            if hasattr(iface, "get_supported_actions"):
                supported = iface.get_supported_actions()
                if isinstance(supported, dict):
                    for act in supported.keys():
                        actions[act] = name

            # Dynamic check for supported actions
            if hasattr(iface, "get_supported_action_types"):
                action_types = iface.get_supported_action_types()
                if isinstance(action_types, (list, set)):
                    for act in action_types:
                        actions[act] = name

        except Exception as e:  # pragma: no cover - defensive
            log_debug(f"[action_parser] Error inspecting interface {name}: {e}")

    _INTERFACE_ACTIONS = actions
    return actions


def get_supported_action_types() -> set[str]:
    """Return all supported action types discovered from plugins, interfaces, and validation registry."""
    supported_types: set[str] = set()

    # Add action types from validation registry (new centralized system)
    try:
        validation_registry = get_validation_registry()
        supported_types.update(validation_registry.get_supported_action_types())
    except Exception as e:
        log_warning(f"[action_parser] Error getting action types from validation registry: {e}")

    # Legacy discovery from plugins
    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_action_types"):
                plugin_types = plugin.get_supported_action_types()
                if isinstance(plugin_types, (list, set)):
                    supported_types.update(plugin_types)
            elif hasattr(plugin, "get_supported_actions"):
                plugin_actions = plugin.get_supported_actions()
                if isinstance(plugin_actions, dict):
                    supported_types.update(plugin_actions.keys())
                elif isinstance(plugin_actions, (list, set, tuple)):
                    supported_types.update(plugin_actions)
    except Exception as e:
        log_warning(f"[action_parser] Error discovering action types: {e}")

    # Legacy discovery from interfaces
    try:
        supported_types.update(_load_interface_actions().keys())
    except Exception as e:  # pragma: no cover - defensive
        log_debug(f"[action_parser] Error loading interface actions: {e}")

    return supported_types


def _validate_payload(action_type: str, payload: dict, errors: List[str]) -> None:
    """Validate payload using centralized validation registry and legacy plugin/interface validation.
    
    This function implements the new Dynamic Component Validation System that removes 
    hardcoded validation rules from the corrector. Components register their validation 
    rules dynamically, and this function applies them automatically.
    
    See docs/validation_system.rst for complete documentation.
    """
    """Validate payload using centralized validation registry and legacy plugin/interface validation."""
    
    # First, use the centralized validation registry (new system)
    try:
        validation_registry = get_validation_registry()
        registry_errors = validation_registry.validate_action_payload(action_type, payload)
        if registry_errors:
            errors.extend(registry_errors)
            log_debug(f"[action_parser] Validation registry added {len(registry_errors)} errors for {action_type}")
    except Exception as e:
        log_warning(f"[action_parser] Error using validation registry: {e}")
    
    # Legacy validation - keep for backward compatibility until all components migrate
    try:
        for plugin in _load_action_plugins():
            supports_action = False
            try:
                if hasattr(plugin, "get_supported_action_types"):
                    if action_type in plugin.get_supported_action_types():
                        supports_action = True
                elif hasattr(plugin, "get_supported_actions"):
                    actions = plugin.get_supported_actions()
                    if isinstance(actions, dict) and action_type in actions:
                        supports_action = True
                    elif isinstance(actions, (list, set, tuple)) and action_type in actions:
                        supports_action = True
            except Exception as e:
                log_debug(f"[action_parser] Error checking plugin support for {action_type}: {e}")
                continue

            if supports_action:
                if hasattr(plugin, "validate_payload"):
                    try:
                        plugin_errors = plugin.validate_payload(action_type, payload)
                        if plugin_errors and isinstance(plugin_errors, list):
                            errors.extend(plugin_errors)
                            log_debug(
                                f"[action_parser] Plugin {plugin.__class__.__name__} added {len(plugin_errors)} validation errors"
                            )
                    except Exception as e:
                        log_warning(
                            f"[action_parser] Error validating payload with plugin {plugin.__class__.__name__}: {e}"
                        )
                elif hasattr(plugin, "validate_action"):
                    try:
                        action_dict = {"type": action_type, "payload": payload}
                        plugin_errors = plugin.validate_action(action_dict)
                        if plugin_errors and isinstance(plugin_errors, list):
                            errors.extend(plugin_errors)
                            log_debug(
                                f"[action_parser] Plugin {plugin.__class__.__name__} added {len(plugin_errors)} validation errors"
                            )
                    except Exception as e:
                        log_warning(
                            f"[action_parser] Error validating action with plugin {plugin.__class__.__name__}: {e}"
                        )
                else:
                    # Plugin doesn't have validation - that's OK, skip
                    log_debug(
                        f"[action_parser] Plugin {plugin.__class__.__name__} supports {action_type} but has no validation method"
                    )

        # Interface-based validation
        iface_name = _load_interface_actions().get(action_type)
        if iface_name:
            try:
                from core.core_initializer import INTERFACE_REGISTRY
                iface = INTERFACE_REGISTRY.get(iface_name)
                if iface and hasattr(iface, "validate_payload"):
                    iface_errors = iface.validate_payload(action_type, payload)
                    if iface_errors and isinstance(iface_errors, list):
                        errors.extend(iface_errors)
                        log_debug(
                            f"[action_parser] Interface {iface_name} added {len(iface_errors)} validation errors"
                        )
            except Exception as e:  # pragma: no cover - defensive
                log_warning(
                    f"[action_parser] Error validating payload with interface {iface_name}: {e}"
                )
    except Exception as e:
        log_error(f"[action_parser] Error during payload validation: {e}")


def validate_action(action: dict, context: dict = None, original_message=None) -> Tuple[bool, List[str]]:
    """Validate an action dictionary.

    Parameters
    ----------
    action : dict
        Dictionary describing an action.
    context : dict, optional
        Context information for interface inference.
    original_message : optional
        Original message for interface inference.

    Returns
    -------
    tuple[bool, list[str]]
        A tuple containing a boolean validity flag and a list of error messages.
    """

    errors: List[str] = []

    # Ignore optional description fields from the LLM
    if isinstance(action, dict) and "description" in action:
        action = {k: v for k, v in action.items() if k != "description"}

    if not isinstance(action, dict):
        return False, ["action must be a dict"]

    # Validate action type - with specific action names, interface is implicit
    supported_types = get_supported_action_types()
    action_type = action.get("type")
    if not action_type:
        errors.append("Missing 'type'")
    elif action_type not in supported_types:
        # Check if any plugin or interface supports this action type
        errors.append(
            f"Unsupported type '{action_type}' - no plugin or interface found to handle it"
        )

    payload = action.get("payload")
    
    # Some actions (like bio plugins) support both payload and direct field format
    # for backward compatibility
    actions_with_flexible_payload = ["bio_update", "bio_full_request"]
    
    if payload is None and action_type not in actions_with_flexible_payload:
        errors.append("Missing 'payload'")
    elif payload is not None and not isinstance(payload, dict):
        errors.append("'payload' must be a dict")

    # Dynamic validation - delegate to plugins or interfaces that support this action type
    if (isinstance(payload, dict) or action_type in actions_with_flexible_payload) and action_type in supported_types:
        _validate_payload(action_type, payload or {}, errors)

        if _is_restricted_action(action_type):
            mode = RESTRICT_ACTIONS.lower()
            if mode in ("on", "deny_all"):
                errors.append(f"Action '{action_type}' is restricted")
            elif mode == "trainer_only":
                # Check if user is trainer using abstract context
                try:
                    from core.abstract_context import AbstractContext, AbstractUser
                    interface_name = context.get("interface_name", "unknown")
                    user_id = getattr(getattr(original_message, "from_user", None), "id", None)
                    
                    if user_id is not None:
                        abstract_user = AbstractUser(id=user_id, interface_name=interface_name)
                        abstract_context = AbstractContext(interface_name, user=abstract_user)
                        
                        if not abstract_context.is_trainer():
                            errors.append(f"Action '{action_type}' is restricted to trainer")
                except Exception as e:
                    log_warning(f"Could not verify trainer status: {e}")
                    errors.append(f"Action '{action_type}' requires trainer verification")

    return len(errors) == 0, errors


# Cache for discovered action plugins
_ACTION_PLUGINS: List[Any] | None = None


def _load_action_plugins() -> List[Any]:
    """Return plugin instances registered with the core initializer."""
    global _ACTION_PLUGINS
    if _ACTION_PLUGINS is not None:
        log_debug(f"[action_parser] ðŸ”„ Returning cached plugins ({len(_ACTION_PLUGINS)})")
        return _ACTION_PLUGINS

    try:
        from core.core_initializer import PLUGIN_REGISTRY
    except Exception as e:
        log_warning(f"[action_parser] Unable to access PLUGIN_REGISTRY: {e}")
        PLUGIN_REGISTRY = {}

    _ACTION_PLUGINS = list(PLUGIN_REGISTRY.values())
    log_info(f"[action_parser] ðŸ” Loaded {len(_ACTION_PLUGINS)} plugin(s) from registry")
    return _ACTION_PLUGINS

def _plugins_for(action_type: str) -> List[Any]:
    plugins = []
    loaded_plugins = _load_action_plugins()
    log_debug(
        f"[action_parser] _plugins_for({action_type}): Checking {len(loaded_plugins)} loaded plugins"
    )

    for plugin in loaded_plugins:
        try:
            supported = None

            if hasattr(plugin, "get_supported_action_types"):
                action_types = plugin.get_supported_action_types()
                log_debug(
                    f"[action_parser] Plugin {plugin.__class__.__name__}.get_supported_action_types(): {action_types}"
                )
                if action_types and action_type in action_types:
                    plugins.append(plugin)
                    log_debug(
                        f"[action_parser] âœ… Plugin {plugin.__class__.__name__} supports {action_type} (via action_types)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] âš¡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

            if hasattr(plugin, "get_supported_actions"):
                actions_dict = plugin.get_supported_actions()
                log_debug(
                    f"[action_parser] Plugin {plugin.__class__.__name__}.get_supported_actions(): {actions_dict}"
                )
                if isinstance(actions_dict, dict) and action_type in actions_dict:
                    plugins.append(plugin)
                    log_debug(
                        f"[action_parser] âœ… Plugin {plugin.__class__.__name__} supports {action_type} (via actions_dict)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] âš¡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

        except Exception as e:
            log_error(f"[action_parser] Error querying plugin {plugin}: {repr(e)}")

    try:
        from core.core_initializer import INTERFACE_REGISTRY
    except Exception as e:  # pragma: no cover - defensive
        log_error(f"[action_parser] Error loading INTERFACE_REGISTRY: {e}")
        INTERFACE_REGISTRY = {}

    for name, iface in INTERFACE_REGISTRY.items():
        try:
            supported = None
            if hasattr(iface, "get_supported_action_types"):
                action_types = iface.get_supported_action_types()
                log_debug(
                    f"[action_parser] Interface {name}.get_supported_action_types(): {action_types}"
                )
                if action_types and action_type in action_types:
                    plugins.append(iface)
                    log_debug(
                        f"[action_parser] âœ… Interface {name} supports {action_type} (via action_types)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] âš¡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

            if hasattr(iface, "get_supported_actions"):
                actions_dict = iface.get_supported_actions()
                log_debug(
                    f"[action_parser] Interface {name}.get_supported_actions(): {actions_dict}"
                )
                if isinstance(actions_dict, dict) and action_type in actions_dict:
                    plugins.append(iface)
                    log_debug(
                        f"[action_parser] âœ… Interface {name} supports {action_type} (via actions_dict)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] âš¡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

            log_debug(
                f"[action_parser] âŒ Interface {name} does not support {action_type}"
            )
        except Exception as e:
            log_error(f"[action_parser] Error querying interface {name}: {repr(e)}")

    log_debug(
        f"[action_parser] _plugins_for({action_type}): Found {len(plugins)} supporting plugins"
    )
    return plugins


def set_available_plugins(interfaces, llm_engine, plugins):
    """Set available plugins and their details for the action parser."""
    global ACTIVE_INTERFACES, ACTIVE_LLM_ENGINE, AVAILABLE_PLUGINS

    # Set active interfaces
    ACTIVE_INTERFACES = set(interfaces)
    log_info("[action_parser] Active interfaces set.")

    # Set active LLM engine
    ACTIVE_LLM_ENGINE = llm_engine
    log_info(f"[action_parser] Active LLM engine: {ACTIVE_LLM_ENGINE}")

    # Set available plugins
    AVAILABLE_PLUGINS = plugins
    log_info("[action_parser] Available plugins set.")


# Variables to store the state
ACTIVE_INTERFACES = set()
ACTIVE_LLM_ENGINE = None
AVAILABLE_PLUGINS = []


async def _handle_plugin_action(
    action: Dict[str, Any], context: Dict[str, Any], bot, original_message
):
    action_type = action.get("type")
    iface_target = action.get("interface")
    
    log_info(f"[action_parser] ðŸŽ¯ Handling action: type={action_type}, interface={iface_target}")
    
    plugins = _plugins_for(action_type)
    log_info(f"[action_parser] ðŸ” Found {len(plugins)} plugins for action type '{action_type}'")
    
    if not plugins:
        log_info(
            f"[action_parser] ðŸ“­ No plugin found for action type '{action_type}', attempting interface dispatch"
        )

        # Determine target interface from action or registry mapping
        iface_name = iface_target or _load_interface_actions().get(action_type)
        
        # If interface not found, try to refresh the interface actions cache
        if not iface_name and action_type.startswith("message_"):
            global _INTERFACE_ACTIONS
            _INTERFACE_ACTIONS = None  # Force refresh
            iface_name = _load_interface_actions().get(action_type)

        try:
            from core.core_initializer import INTERFACE_REGISTRY

            interface = INTERFACE_REGISTRY.get(iface_name) if iface_name else None
            if interface and action_type.startswith("message") and hasattr(interface, "send_message"):
                payload = action.get("payload", {})
                log_info(
                    f"[action_parser] âœ‰ï¸ Dispatching message action to interface '{iface_name}'"
                )
                try:
                    result = interface.send_message(payload, original_message)
                    if inspect.iscoroutine(result):
                        await result
                    return None
                except Exception as e:
                    log_error(
                        f"[action_parser] âŒ Error executing {action_type} via interface {iface_name}: {repr(e)}"
                    )
                return
        except Exception as e:  # pragma: no cover - defensive
            log_warning(f"[action_parser] Interface dispatch failed: {e}")

        log_error(f"[action_parser] âŒ No plugin or interface supports action type '{action_type}'")
        return
    
    for plugin in plugins:
        plugin_iface = getattr(
            plugin.__class__, "get_interface_id", lambda: plugin.__class__.__name__.lower()
        )()

        log_info(
            f"[action_parser] ðŸ”Œ Checking plugin: {plugin.__class__.__name__} (plugin_interface: {plugin_iface})"
        )

        if iface_target and plugin_iface != iface_target:
            log_info(
                f"[action_parser] â­ï¸ Skipping plugin {plugin_iface} (target: {iface_target})"
            )
            continue

        # If this plugin is an interface and exposes send_message, allow it to
        # handle message_* actions (interfaces use send_message rather than
        # execute_action). This ensures message actions are dispatched to
        # interfaces properly.
        if hasattr(plugin, "send_message") and action_type.startswith("message"):
            try:
                payload = action.get("payload", {})
                log_info(
                    f"[action_parser] âœ‰ï¸ Dispatching message action to interface '{plugin_iface}' via send_message"
                )
                result = plugin.send_message(payload, original_message)
                if inspect.iscoroutine(result):
                    await result
                log_info(
                    f"[action_parser] âœ… Successfully executed message action via {plugin_iface}"
                )
                return None
            except Exception as e:
                log_error(
                    f"[action_parser] âŒ Error executing {action_type} via interface {plugin_iface}: {repr(e)}"
                )
                continue

        if hasattr(plugin, "execute_action"):
            try:
                payload = action.get("payload", {})
                if not isinstance(payload, dict):
                    payload = vars(payload)
                new_action = {**action, "payload": payload}
                log_info(
                    f"[action_parser] ðŸš€ Delegating action to {plugin.__class__.__name__}: type={action_type} interface={plugin_iface}"
                )
                log_debug(f"[action_parser] ðŸ“¦ Action payload: {payload}")

                result = plugin.execute_action(
                    new_action, context, bot, original_message
                )
                if inspect.iscoroutine(result):
                    await result
                log_info(
                    f"[action_parser] âœ… Successfully executed action via {plugin_iface}"
                )
                return None
            except Exception as e:
                log_error(
                    f"[action_parser] âŒ Error executing {action_type} with {plugin.__class__.__name__}: {repr(e)}"
                )
                import traceback
                log_error(f"[action_parser] ðŸ“„ Full traceback: {traceback.format_exc()}")
        else:
            log_warning(
                f"[action_parser] âš ï¸ Plugin {plugin.__class__.__name__} has no execute_action() method"
            )

    # No matching plugin found - collect error for auto-correction
    available_interfaces = list(ACTIVE_INTERFACES) if ACTIVE_INTERFACES else ["No interfaces registered"]
    error_msg = f"Interface '{iface_target}' not found for action '{action_type}'. Available interfaces: {', '.join(available_interfaces)}"
    
    log_error(f"[action_parser] ðŸ’¥ No plugin matched interface '{iface_target}' for action '{action_type}'")
    return {"error": error_msg, "action": action, "available_interfaces": available_interfaces}


async def run_action(action: Any, context: Dict[str, Any], bot, original_message):
    """Validate and execute a single action or list of actions."""
    log_info(f"[action_parser] ðŸŽ¬ run_action called with action: {action}")
    
    if isinstance(action, list):
        log_info(f"[action_parser] ðŸ“‹ Processing action list with {len(action)} items")
        return await run_actions(action, context, bot, original_message)

    valid, errors = validate_action(action, context, original_message)
    if not valid:
        error_msg = f"Invalid action: {errors}"
        log_error(f"[action_parser] âŒ {error_msg}")
        return {"error": error_msg}

    action_type = action.get("type")
    action_interface = action.get("interface")
    log_info(f"[action_parser] ðŸš€ Executing action: type={action_type}, interface={action_interface}")

    # Use plugin system for all action types (including messages)
    result = await _handle_plugin_action(action, context, bot, original_message)
    return result


async def _request_selective_correction(failed_actions, successful_actions, bot, context, original_message):
    """Request LLM to fix only the failed actions, while preserving successful ones."""
    from core.transport_layer import run_corrector_middleware
    
    # Build clear correction prompt
    successful_count = len(successful_actions)
    failed_count = len(failed_actions)
    
    # Extract successful action types for context
    successful_types = [action.get("type", "unknown") for action in successful_actions]
    
    # Build detailed error descriptions
    error_details = []
    for failed in failed_actions:
        action = failed["action"]
        errors = failed["errors"]
        error_details.append({
            "action_type": action.get("type", "unknown"),
            "errors": errors,
            "original_action": action
        })
    
    # Create a specialized correction prompt that only asks for failed actions
    correction_context = {
        "previous_response_status": "partial_success",
        "successful_actions": successful_count,
        "successful_types": successful_types,
        "failed_actions": failed_count,
        "correction_needed": True,
        "instruction": f"""
Your previous response was partially successful:
âœ… {successful_count} actions executed successfully: {', '.join(successful_types) if successful_types else 'none'}
âŒ {failed_count} actions failed and need correction

Please provide ONLY the corrected versions of the failed actions. Do not repeat the {successful_count} successful actions.

Failed actions with errors:
"""
    }
    
    for i, detail in enumerate(error_details, 1):
        correction_context["instruction"] += f"\n{i}. Action '{detail['action_type']}' failed:\n"
        for error in detail['errors']:
            correction_context["instruction"] += f"   - {error}\n"
    
    correction_context["instruction"] += f"""
Respond with JSON containing only the corrected actions (not the successful ones):
{{
  "actions": [
    // Only the fixed versions of failed actions here
  ]
}}

IMPORTANT: Do not include the {successful_count} actions that were already executed successfully ({', '.join(successful_types) if successful_types else 'none'}).
"""
    
    log_info(f"[action_parser] Requesting selective correction for {failed_count} failed actions (preserving {successful_count} successful ones)")
    log_debug(f"[action_parser] Correction context: {correction_context}")
    
    try:
        # Create a synthetic message with correction context
        import types
        correction_message = types.SimpleNamespace()
        correction_message.chat_id = getattr(original_message, 'chat_id', None)
        correction_message.from_llm = True
        correction_message.original_text = correction_context["instruction"]
        correction_message.text = correction_context["instruction"]
        
        # Use existing corrector middleware but with selective context
        await run_corrector_middleware(
            text=correction_context["instruction"],
            bot=bot,
            context={**context, "selective_correction": True, "correction_context": correction_context},
            chat_id=getattr(original_message, 'chat_id', None)
        )
    except Exception as e:
        log_error(f"[action_parser] Failed to request selective correction: {e}")


async def run_actions(actions: Any, context: Dict[str, Any], bot, original_message):
    """Execute multiple actions in sequence.

    If ``actions`` is a single dict, it will be wrapped in a list.
    Valid actions are executed, invalid actions are collected for selective correction.
    
    Returns:
        dict: {"processed": [successful_actions], "errors": [error_messages], "failed_actions": [failed_actions]}
    """
    if actions is None:
        return {"processed": [], "errors": [], "failed_actions": []}

    if isinstance(actions, dict):
        actions = [actions]
    elif not isinstance(actions, list):
        error_msg = "[action_parser] run_actions expects a list or dict"
        log_error(error_msg)
        return {"processed": [], "errors": [error_msg], "failed_actions": []}

    log_debug(f"[action_parser] run_actions called with {len(actions)} actions")
    log_debug(f"[action_parser] Actions: {actions}")

    processed_actions = []
    collected_errors = []
    failed_actions = []
    action_outputs: List[Dict[str, Any]] = []
    terminal_seen = False

    for idx, action in enumerate(actions):
        try:
            action_type = action.get("type")

            # Halt processing of subsequent non-terminal actions until the LLM
            # has seen the outputs from executed terminal commands.
            if terminal_seen and action_type != "terminal":
                log_info(
                    "[action_parser] â¸ï¸ Waiting for LLM response before executing remaining actions"
                )
                break

            valid, errors = validate_action(action, context, original_message)
            if not valid:
                error_msg = f"Invalid action {idx}: {errors}"
                log_warning(f"[action_parser] Skipping {error_msg}")
                collected_errors.append(error_msg)
                failed_actions.append({"index": idx, "action": action, "errors": errors})
                continue

            log_debug(f"[action_parser] Running action {idx}: {action_type}")
            result = await run_action(action, context, bot, original_message)

            # Check if run_action returned error info
            if isinstance(result, dict) and "error" in result:
                collected_errors.append(result["error"])
                failed_actions.append({"index": idx, "action": action, "errors": [result["error"]]})
            else:
                processed_actions.append(action)

                if action_type == "terminal" and isinstance(result, str):
                    terminal_seen = True
                    action_outputs.append(
                        {
                            "type": "terminal",
                            "command": action.get("payload", {}).get("command", ""),
                            "output": result,
                        }
                    )

        except Exception as e:
            error_msg = f"Error executing action {idx}: {repr(e)}"
            log_error(f"[action_parser] {error_msg}")
            collected_errors.append(error_msg)
            failed_actions.append({"index": idx, "action": action, "errors": [error_msg]})

    # After all actions processed, mark scheduled event as delivered if applicable
    event_id = context.get("event_id") or getattr(original_message, "event_id", None)
    if event_id:
        try:
            from core import db

            if await db.mark_event_delivered(event_id):
                log_info(f"[action_parser] Event {event_id} marked delivered")
            else:
                log_warning(f"[action_parser] Failed to mark event {event_id} delivered")
        except Exception as e:
            log_warning(f"[action_parser] Error marking event {event_id} delivered: {e}")
        try:
            from core import event_dispatcher

            event_dispatcher.event_completed(event_id)
        except Exception as e:
            log_warning(
                f"[action_parser] Failed to clear processing flag for event {event_id}: {e}"
            )

    if action_outputs:
        interface_name = context.get("interface")
        if not interface_name:
            log_error("No interface specified in action_parser context")
            return

        response_context = {
            "chat_id": getattr(original_message, "chat_id", None),
            "message_id": getattr(original_message, "message_id", None),
            "interface_name": interface_name,
            "thread_id": getattr(original_message, "thread_id", None),
        }

        try:
            from core.auto_response import request_llm_delivery

            await request_llm_delivery(
                action_outputs=action_outputs,
                original_context=response_context,
                action_type="terminal",
            )
        except Exception as e:
            log_warning(
                f"[action_parser] Failed to request LLM delivery for action outputs: {e}"
            )

    if collected_errors and failed_actions:
        # New selective corrector: only ask LLM to fix failed actions, not successful ones
        if hasattr(original_message, 'from_llm') and original_message.from_llm:
            try:
                await _request_selective_correction(
                    failed_actions=failed_actions,
                    successful_actions=processed_actions,
                    bot=bot,
                    context=context,
                    original_message=original_message
                )
            except Exception as e:
                log_warning(f"[action_parser] Failed to invoke selective correction: {e}")
        else:
            log_debug("[action_parser] Errors found but message is not from LLM; skipping correction to prevent loops")

    # Create diary entry for this interaction
    await _create_diary_entry_for_actions(processed_actions, context, original_message)

    return {
        "processed": processed_actions,
        "errors": collected_errors,
        "failed_actions": failed_actions,
        "action_outputs": action_outputs,
    }


async def _create_diary_entry_for_actions(processed_actions, context, original_message):
    """Create a diary entry summarizing the actions performed during this interaction."""
    if not processed_actions:
        return
    
    try:
        from plugins.ai_diary import create_personal_diary_entry, is_plugin_enabled
        
        if not is_plugin_enabled():
            log_debug("[action_parser] Diary plugin disabled, skipping diary entry")
            return
        
        # Extract relevant information
        interface_name = context.get("interface", "unknown")
        chat_id = getattr(original_message, "chat_id", None)
        thread_id = getattr(original_message, "thread_id", None)
        
        # Get user message from context or original_message
        user_message = ""
        if hasattr(original_message, "text"):
            user_message = original_message.text
        elif isinstance(original_message, dict) and "text" in original_message:
            user_message = original_message["text"]
        elif context and "input" in context and "payload" in context["input"]:
            payload = context["input"]["payload"]
            if "text" in payload:
                user_message = payload["text"]
        
        # Extract people involved from context participants for logging
        involved_people = set()
        if context and "participants" in context:
            for participant in context["participants"]:
                if "usertag" in participant:
                    # Remove @ from usertag
                    username = participant["usertag"].lstrip('@')
                    involved_people.add(username)
                # Also add nicknames if available
                if "nicknames" in participant and participant["nicknames"]:
                    for nickname in participant["nicknames"]:
                        if nickname and nickname.lower() not in ["rekku", "bot"]:
                            involved_people.add(nickname)
        
        # Convert to list for logging purposes only (not passed to diary)
        involved_list = [person for person in involved_people if person.lower() not in ["rekku", "bot"]]
        
        # Generate comprehensive response content from all actions
        rekku_response_parts = []
        action_types = [action.get("type", "unknown") for action in processed_actions]
        
        # Extract actual text from message actions
        for action in processed_actions:
            action_type = action.get("type", "")
            payload = action.get("payload", {})
            
            if action_type.startswith("message_"):
                text = payload.get("text", "")
                if text:
                    rekku_response_parts.append(text)
            elif action_type == "terminal":
                command = payload.get("command", "")
                if command:
                    rekku_response_parts.append(f"Executed command: {command}")
            elif action_type == "bio_update":
                target = payload.get("target", "someone")
                rekku_response_parts.append(f"Updated bio information for {target}")
            elif action_type == "event":
                description = payload.get("description", "created an event")
                rekku_response_parts.append(f"Scheduled event: {description}")
        
        # If no specific content found, create a summary
        if not rekku_response_parts:
            action_counts = {}
            for action_type in action_types:
                action_counts[action_type] = action_counts.get(action_type, 0) + 1
            
            if len(action_counts) == 1:
                action_type = list(action_counts.keys())[0]
                count = action_counts[action_type]
                if count == 1:
                    rekku_response_parts.append(f"Performed {action_type} action")
                else:
                    rekku_response_parts.append(f"Performed {count} {action_type} actions")
            else:
                action_summary = ", ".join([f"{count} {action_type}" for action_type, count in action_counts.items()])
                rekku_response_parts.append(f"Performed multiple actions: {action_summary}")
        
        rekku_response = " | ".join(rekku_response_parts)
        
        # Generate context tags based on action types and content
        context_tags = _generate_context_tags(action_types, rekku_response, user_message, interface_name)
        
        # Use create_personal_diary_entry for automatic thought and emotion generation
        create_personal_diary_entry(
            rekku_response=rekku_response,
            user_message=user_message if user_message else None,
            context_tags=context_tags,
            involved_users=involved_list,
            interface=interface_name,
            chat_id=str(chat_id) if chat_id else None,
            thread_id=str(thread_id) if thread_id else None
        )
        
        log_debug(f"[action_parser] Created personal diary entry: {rekku_response[:100]}...")
        
    except Exception as e:
        log_warning(f"[action_parser] Failed to create diary entry: {e}")
        import traceback
        log_debug(f"[action_parser] Diary error traceback: {traceback.format_exc()}")


def _generate_context_tags(action_types: List[str], rekku_response: str, user_message: str, interface_name: str) -> List[str]:
    """Generate specific context tags based on action types and conversation content."""
    context_tags = []
    
    # Action-based tags (more specific than before)
    if "bio_update" in action_types or "bio_full_request" in action_types:
        context_tags.append("personal_info")
    if "terminal" in action_types:
        context_tags.append("technical")
    if "event" in action_types:
        context_tags.append("scheduling")
    if "speech_selenium_elevenlabs" in action_types or "audio_telegram_bot" in action_types:
        context_tags.append("audio")
    
    # Content-based analysis for specific topics
    combined_text = (rekku_response + " " + (user_message or "")).lower()
    
    # Food and dining
    if any(word in combined_text for word in ["food", "eat", "cooking", "recipe", "restaurant", "meal"]):
        context_tags.append("food")
        # Specific food types
        if any(word in combined_text for word in ["sushi", "japanese"]):
            context_tags.append("sushi")
        if any(word in combined_text for word in ["pizza", "italian"]):
            context_tags.append("pizza") 
        if any(word in combined_text for word in ["restaurant", "dining"]):
            context_tags.append("restaurant")
    
    # Cars and vehicles
    if any(word in combined_text for word in ["car", "auto", "vehicle", "driving", "motor", "bmw", "audi", "honda"]):
        context_tags.append("cars")
        if any(word in combined_text for word in ["color", "blue", "red", "black", "white"]):
            context_tags.append("colors")
    
    # Technology and computers
    if any(word in combined_text for word in ["computer", "software", "programming", "code", "tech"]):
        context_tags.append("technology")
    
    # Entertainment
    if any(word in combined_text for word in ["movie", "music", "game", "book", "entertainment"]):
        context_tags.append("entertainment")
    
    # Location and travel
    if any(word in combined_text for word in ["travel", "vacation", "city", "country", "location"]):
        context_tags.append("travel")
    
    # Work and career
    if any(word in combined_text for word in ["work", "job", "career", "office", "business"]):
        context_tags.append("work")
    
    # Health and wellness
    if any(word in combined_text for word in ["health", "exercise", "fitness", "medical"]):
        context_tags.append("health")
    
    # Family and relationships
    if any(word in combined_text for word in ["family", "friend", "relationship", "love", "marriage"]):
        context_tags.append("relationships")
    
    # Only add help tag for explicit help requests
    if any(word in combined_text for word in ["help me", "can you help", "need help", "assistance"]):
        context_tags.append("help")
    
    # Only add learning tag for explicit learning conversations
    if any(word in combined_text for word in ["learn", "teach", "explain", "understand", "study"]):
        context_tags.append("learning")
    
    # Only add problem tag for explicit problem-solving
    if any(word in combined_text for word in ["problem", "issue", "error", "fix", "solve", "bug"]):
        context_tags.append("problem")
    
    # Remove duplicate tags and return
    return list(set(context_tags))


async def parse_action(action: dict, bot, message):
    """Parse and execute a single action."""
    log_debug(f"[action_parser] Received action: {action}")

    action_type = action.get("type")
    interface = action.get("interface")
    payload = action.get("payload")

    if not action_type or not payload:
        log_warning("[action_parser] Invalid action structure: missing type or payload")
        return

    log_debug(
        "[action_parser] Action type: "
        + str(action_type)
        + ", Interface: "
        + str(interface)
        + ", Payload: "
        + str(payload)
    )

    # First allow the active LLM plugin to handle custom actions
    import core.plugin_instance as plugin_instance
    llm_plugin = getattr(plugin_instance, "plugin", None)
    if llm_plugin:
        try:
            supported = []
            if hasattr(llm_plugin, "get_supported_action_types"):
                supported = llm_plugin.get_supported_action_types()
            elif hasattr(llm_plugin, "get_supported_actions"):
                acts = llm_plugin.get_supported_actions()
                if isinstance(acts, dict):
                    supported = list(acts.keys())
            if action_type in supported and hasattr(llm_plugin, "handle_custom_action"):
                await llm_plugin.handle_custom_action(action_type, payload)
                return
        except Exception:
            pass

    # Use centralized action plugin system for all other action types
    action_plugins = _plugins_for(action_type)
    if action_plugins:
        action_handled = False
        for plugin in action_plugins:
            try:
                if hasattr(plugin, "execute_action"):
                    result = plugin.execute_action(action, {}, bot, message)
                    if inspect.iscoroutine(result):
                        await result
                    action_handled = True
                    log_debug(f"[action_parser] Action {action_type} handled by {plugin.__class__.__name__}")
                    break  # Stop after first successful handler
                elif hasattr(plugin, "handle_custom_action"):
                    await plugin.handle_custom_action(action_type, payload)
                    action_handled = True
                    log_debug(f"[action_parser] Action {action_type} handled by {plugin.__class__.__name__} (custom)")
                    break  # Stop after first successful handler
                else:
                    log_warning(
                        f"[action_parser] Plugin {plugin.__class__.__name__} lacks execute_action/handle_custom_action methods"
                    )
            except Exception as e:
                log_error(
                    f"[action_parser] Error delegating {action_type} to plugin {plugin.__class__.__name__}: {repr(e)}"
                )
        
        if action_handled:
            log_debug(f"[action_parser] Action {action_type} successfully handled")
        else:
            log_warning(f"[action_parser] No plugin successfully handled action {action_type}")
        return

    log_warning(
        f"[action_parser] No plugin supports action type '{action_type}' â€” no plugin handler found"
    )


async def initialize_core(notify_fn=None):
    """Initialize and log all core components."""
    from core.core_initializer import core_initializer

    return await core_initializer.initialize_all(notify_fn=notify_fn)


def get_action_plugin_instructions() -> dict[str, dict]:
    """Gather prompt instructions from all action plugins."""
    instructions: dict[str, str] = {}
    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_actions") and hasattr(plugin, "get_prompt_instructions"):
                supported = plugin.get_supported_actions()
                for action in supported:
                    try:
                        instr = plugin.get_prompt_instructions(action)
                        if instr:
                            instructions[action] = instr
                    except Exception:
                        log_warning(
                            f"[action_parser] Plugin {plugin.__class__.__name__} missing prompt instructions for '{action}'"
                        )
    except Exception as e:
        log_error(f"[action_parser] Error collecting plugin prompt instructions: {repr(e)}")

    return instructions


async def gather_static_injections(message=None, context_memory=None) -> dict:
    """Collect static injections from plugins supporting the ``static_inject`` action.

    Parameters
    ----------
    message : optional
        The original message associated with the prompt. Passed to plugins that
        accept it for participant resolution.
    context_memory : optional
        Memory structure containing recent chat messages. Also passed to
        plugins if they accept it.
    """

    injections: dict = {}
    try:
        for plugin in _load_action_plugins():
            try:
                supported = False
                if hasattr(plugin, "get_supported_action_types"):
                    types = plugin.get_supported_action_types()
                    if types and "static_inject" in types:
                        supported = True
                elif hasattr(plugin, "get_supported_actions"):
                    acts = plugin.get_supported_actions()
                    if isinstance(acts, dict):
                        supported = "static_inject" in acts
                    elif isinstance(acts, (list, set, tuple)):
                        supported = "static_inject" in acts
                if not supported or not hasattr(plugin, "get_static_injection"):
                    continue

                # Pass message and context_memory if the plugin expects them
                try:
                    result = plugin.get_static_injection(message, context_memory)
                except TypeError:
                    try:
                        result = plugin.get_static_injection()
                    except Exception as inner_e:
                        log_error(f"[action_parser] Error calling get_static_injection() on {plugin.__class__.__name__}: {inner_e}")
                        continue

                if inspect.iscoroutine(result):
                    result = await result
                if isinstance(result, dict):
                    injections.update(result)
            except Exception as e:
                log_error(
                    f"[action_parser] Error gathering static injection from {plugin.__class__.__name__}: {e}"
                )
    except Exception as e:
        log_error(f"[action_parser] Error collecting static injections: {e}")
    return injections


def _is_restricted_action(action_type: str) -> bool:
    """Return True if the action is marked as restricted."""
    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_actions"):
                actions = plugin.get_supported_actions()
                if isinstance(actions, dict):
                    meta = actions.get(action_type)
                    if isinstance(meta, dict) and meta.get("restricted"):
                        return True
    except Exception:
        pass
    try:  # Check interface actions as well
        from core.core_initializer import INTERFACE_REGISTRY
        for iface in INTERFACE_REGISTRY.values():
            if hasattr(iface, "get_supported_actions"):
                actions = iface.get_supported_actions()
                if isinstance(actions, dict):
                    meta = actions.get(action_type)
                    if isinstance(meta, dict) and meta.get("restricted"):
                        return True
    except Exception:
        pass
    return False


__all__ = [
    "run_action",
    "run_actions",
    "parse_action",
    "validate_action",
    "initialize_core",
    "get_action_plugin_instructions",
    "gather_static_injections",
    "corrector_orchestrator",
]


async def corrector_orchestrator(text: str, context: dict, bot, message, max_retries: int | None = None, completed_actions: list = None):
    """Process model text: parse JSON actions or run the corrector loop.
    
    Args:
        text: The text to parse/correct
        context: Context information
        bot: Bot instance
        message: Message object
        max_retries: Maximum number of correction attempts
        completed_actions: List of action types that were already successfully executed
                          (so the corrector knows not to regenerate them)

    Returns:
        True  -> actions parsed and executed
        False -> blocked (corrector exhausted or not allowed)
        None  -> not JSON-like; caller may forward as plain text
    """
    # Only handle messages that explicitly originate from the LLM.
    # Transport layer / llm engines must set `message.from_llm = True` when passing
    # LLM outputs into this orchestrator. Any message without this flag is ignored
    # here so system- or interface-originated payloads are not processed.
    if message is not None and not getattr(message, "from_llm", False):
        log_debug("[corrector_orchestrator] Ignoring message: not marked as LLM-origin (message.from_llm is False or missing)")
        return None

    # Determine max retries
    if max_retries is None:
        max_retries = CORRECTOR_RETRIES
    
    # Initialize completed_actions if not provided
    if completed_actions is None:
        completed_actions = []

    # Quick parse attempt
    parsed = None
    try:
        parsed = _extract_json_local(text)
    except Exception as e:
        log_debug(f"[corrector_orchestrator] initial parse failed: {e}")

    if parsed is not None:
        # Build actions list similar to transport layer
        if isinstance(parsed, dict) and "actions" in parsed:
            actions = parsed["actions"] if isinstance(parsed["actions"], list) else None
            if actions is None:
                log_warning("[corrector_orchestrator] actions field must be a list")
                return None
        elif isinstance(parsed, list):
            actions = parsed
        elif isinstance(parsed, dict) and "type" in parsed:
            actions = [parsed]
        else:
            log_warning(f"[corrector_orchestrator] Unrecognized JSON structure: {parsed}")
            return None
        
        # Filter out already completed actions to avoid duplicates (e.g., double diary entries)
        if completed_actions:
            original_count = len(actions)
            actions = [a for a in actions if a.get('type') not in completed_actions]
            if len(actions) < original_count:
                log_info(f"[corrector_orchestrator] Filtered out {original_count - len(actions)} already-completed actions: {completed_actions}")
        
        # If no actions left after filtering, we're done
        if not actions:
            log_info("[corrector_orchestrator] All actions were already completed - nothing to regenerate")
            return True

        try:
            result = await run_actions(actions, context, bot, message)
            # Check if any actions were processed successfully
            if isinstance(result, dict) and result.get("processed"):
                log_info('[corrector_orchestrator] Actions executed successfully - interrupting correction loop')
                return True
            elif isinstance(result, dict) and result.get("errors"):
                log_warning(f'[corrector_orchestrator] Actions failed with errors: {result.get("errors")}')
                return False
            else:
                log_info('[corrector_orchestrator] Actions executed successfully - interrupting correction loop')
                return True
        except Exception as e:
            log_warning(f"[corrector_orchestrator] Failed to run actions: {e}")
            return False

    # Not parsed initially. If not JSON-like, indicate to caller to forward as plain text
    if '{' not in (text or '') and '[' not in (text or ''):
        return None

    # JSON-like but not valid -> run corrector loop here
    # Build context for corrector, including completed actions
    if completed_actions:
        log_info(f"[corrector_orchestrator] Starting correction loop - actions already completed: {completed_actions}")
        context = dict(context) if context else {}
        context['completed_actions'] = completed_actions
        context['instruction'] = f"The previous response had corrupted JSON. These actions were already successfully executed: {', '.join(completed_actions)}. Please regenerate ONLY the missing/corrupted actions. Do NOT regenerate: {', '.join(completed_actions)}"
    
    tried_texts = set()
    attempt = 0
    while attempt < max_retries:
        # Check retry permission
        if not _should_retry(message, max_retries=max_retries):
            retry_key = _get_retry_key(message)
            retry_count, _ = _retry_tracker.get(retry_key, (0, 0))
            log_warning(f"[corrector_orchestrator] Max retries ({retry_count}) reached for {retry_key}; blocking")
            return False

        # increment retry counter
        attempt_count = _increment_retry(message)
        attempt += 1

        # Call the corrector (transport-layer middleware)
        try:
            import core.transport_layer as transport
            # Add message to context for error handling
            context = dict(context) if context else {}
            context['message'] = message
            corrected = await transport.run_corrector_middleware(text, bot=bot, context=context, chat_id=getattr(message, 'chat_id', None))
        except Exception as e:
            log_warning(f"[corrector_orchestrator] Corrector invocation failed: {e}")
            return False

        if corrected is None:
            log_debug(f"[corrector_orchestrator] Corrector returned None on attempt {attempt}")
            # corrected failed; loop will check retry and possibly continue
            text = text  # keep original or last value
            continue

        # If corrected same as previous tried value, avoid infinite loop
        if corrected in tried_texts:
            log_warning("[corrector_orchestrator] Corrector returned previously seen output; attempting to execute already-parsed actions if available")
            # Try to execute already-parsed actions from the original text instead of blocking completely
            if parsed is not None:
                log_info("[corrector_orchestrator] Attempting to execute actions from originally-parsed JSON before blocking")
                # Build actions list
                if isinstance(parsed, dict) and "actions" in parsed:
                    actions = parsed["actions"] if isinstance(parsed["actions"], list) else None
                elif isinstance(parsed, list):
                    actions = parsed
                elif isinstance(parsed, dict) and "type" in parsed:
                    actions = [parsed]
                else:
                    actions = None
                
                if actions:
                    # Filter out already-completed actions
                    if completed_actions:
                        original_count = len(actions)
                        actions = [a for a in actions if a.get('type') not in completed_actions]
                        log_info(f"[corrector_orchestrator] Filtered {original_count - len(actions)} already-completed actions")
                    
                    if actions:
                        try:
                            result = await run_actions(actions, context, bot, message)
                            if isinstance(result, dict) and result.get("processed"):
                                log_info('[corrector_orchestrator] Successfully executed originally-parsed actions despite loop')
                                return True
                        except Exception as e:
                            log_warning(f"[corrector_orchestrator] Failed to execute originally-parsed actions: {e}")
            
            log_warning("[corrector_orchestrator] No valid actions to execute; blocking due to loop")
            return False
        tried_texts.add(corrected)

        # Try parsing corrected
        try:
            parsed2 = _extract_json_local(corrected)
        except Exception as e:
            parsed2 = None
            log_debug(f"[corrector_orchestrator] Parsing corrected failed: {e}")

        if parsed2 is not None:
            # run actions
            if isinstance(parsed2, dict) and "actions" in parsed2:
                actions = parsed2["actions"] if isinstance(parsed2["actions"], list) else None
                if actions is None:
                    log_warning("[corrector_orchestrator] corrected actions field must be a list")
                    return False
            elif isinstance(parsed2, list):
                actions = parsed2
            elif isinstance(parsed2, dict) and "type" in parsed2:
                actions = [parsed2]
            else:
                log_warning(f"[corrector_orchestrator] Unrecognized corrected JSON structure: {parsed2}")
                return False

            try:
                result = await run_actions(actions, context, bot, message)
                # Check if any actions were processed successfully
                if isinstance(result, dict) and result.get("processed"):
                    log_info('[corrector_orchestrator] Corrected actions executed successfully - interrupting correction loop')
                    return True
                elif isinstance(result, dict) and result.get("errors"):
                    log_warning(f'[corrector_orchestrator] Corrected actions failed with errors: {result.get("errors")}')
                    return False
                else:
                    log_info('[corrector_orchestrator] Corrected actions executed successfully - interrupting correction loop')
                    return True
            except Exception as e:
                log_warning(f"[corrector_orchestrator] Failed to run actions after correction: {e}")
                return False

        # Not parsed; set text to corrected and retry
        text = corrected

    # Exhausted retries
    log_warning(f"[corrector_orchestrator] Exhausted {max_retries} correction attempts; blocking message for chat {getattr(message, 'chat_id', None)}")
    return False

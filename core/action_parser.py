# core/action_parser.py
"""Execute actions generated by Rekku."""

import asyncio
import importlib
import inspect
import os
from collections import deque
from types import SimpleNamespace
from datetime import datetime
from typing import Any, Dict, List, Tuple

import core.plugin_instance as plugin_instance
from core.logging_utils import log_debug, log_info, log_warning, log_error


# Supporto per tipi di azione - ora dinamico, basato sui plugin caricati
SUPPORTED_TYPES = {
    "message",
    "event",
    "command",
    "memory",
}  # Base types, expandable by plugins


def get_supported_action_types():
    """Get all supported action types from loaded plugins."""
    supported_types = set(SUPPORTED_TYPES)  # Start with base types

    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_action_types"):
                plugin_types = plugin.get_supported_action_types()
                if isinstance(plugin_types, (list, set)):
                    supported_types.update(plugin_types)
            elif hasattr(plugin, "get_supported_actions"):
                plugin_actions = plugin.get_supported_actions()
                if isinstance(plugin_actions, dict):
                    supported_types.update(plugin_actions.keys())
                elif isinstance(plugin_actions, (list, set, tuple)):
                    supported_types.update(plugin_actions)
    except Exception as e:
        log_warning(f"[action_parser] Error discovering plugin action types: {e}")

    return supported_types


def _validate_message_payload(payload: dict, errors: List[str]) -> None:
    """Validate payload for message actions."""
    text = payload.get("text")
    if not isinstance(text, str) or not text:
        errors.append("payload.text must be a non-empty string")

    # target può essere un int (chat_id diretto) o un dict - rendiamo flessibile
    target = payload.get("target")
    if target is not None:
        if isinstance(target, dict):
            # Formato complesso con chat_id e message_id
            chat_id = target.get("chat_id")
            message_id = target.get("message_id")
            if not isinstance(chat_id, int):
                errors.append("payload.target.chat_id must be an int")
            if message_id is not None and not isinstance(message_id, int):
                errors.append("payload.target.message_id must be an int")
        elif not isinstance(target, int):
            # Formato semplice: solo chat_id come int
            errors.append(
                "payload.target must be an int (chat_id) or dict with chat_id and message_id"
            )

    # scope e privacy sono completamente opzionali - non li validare se non presenti
    scope = payload.get("scope")
    if scope is not None and scope not in {"local", "global"}:
        errors.append("payload.scope must be 'local' or 'global'")

    privacy = payload.get("privacy")
    if privacy is not None and privacy not in {"default", "private", "public"}:
        errors.append("payload.privacy must be one of ['default', 'private', 'public']")

    message_thread_id = payload.get("message_thread_id")
    if message_thread_id is not None and not isinstance(message_thread_id, int):
        errors.append("payload.message_thread_id must be an int")


def _validate_command_payload(payload: dict, errors: List[str]) -> None:
    """Validate payload for command actions."""
    name = payload.get("name")
    if not isinstance(name, str) or not name:
        errors.append("payload.name must be a non-empty string for command action")

    args = payload.get("args")
    if args is not None and not isinstance(args, list):
        errors.append("payload.args must be a list if provided")


def _validate_memory_payload(payload: dict, errors: List[str]) -> None:
    """Validate payload for memory actions."""
    content = payload.get("content")
    if not isinstance(content, str) or not content:
        errors.append("payload.content must be a non-empty string")

    tags = payload.get("tags")
    if tags is not None:
        if not isinstance(tags, list) or not all(isinstance(tag, str) for tag in tags):
            errors.append("payload.tags must be a list of strings if provided")


def validate_action(action: dict) -> Tuple[bool, List[str]]:
    """Validate an action dictionary.

    Parameters
    ----------
    action : dict
        Dictionary describing an action.

    Returns
    -------
    tuple[bool, list[str]]
        A tuple containing a boolean validity flag and a list of error messages.
    """

    errors: List[str] = []

    if not isinstance(action, dict):
        return False, ["action must be a dict"]

    action_type = action.get("type")
    if not action_type:
        errors.append("Missing 'type'")
    else:
        # Check if any plugin supports this action type
        supported_by_plugin = False
        for plugin in _load_action_plugins():
            try:
                if hasattr(plugin, "get_supported_action_types"):
                    if action_type in plugin.get_supported_action_types():
                        supported_by_plugin = True
                        break
                elif hasattr(plugin, "get_supported_actions"):
                    actions = plugin.get_supported_actions()
                    if isinstance(actions, dict) and action_type in actions:
                        supported_by_plugin = True
                        break
                    elif isinstance(actions, (list, set, tuple)) and action_type in actions:
                        supported_by_plugin = True
                        break
            except Exception as e:
                log_debug(
                    f"[action_parser] Error checking plugin support for {action_type}: {e}"
                )
                continue

        if not supported_by_plugin:
            errors.append(
                f"Unsupported type '{action_type}' - no plugin found to handle it"
            )

    payload = action.get("payload")
    if payload is None:
        errors.append("Missing 'payload'")
    elif not isinstance(payload, dict):
        errors.append("'payload' must be a dict")

    # Legacy validation for base types (can be removed once all plugins handle their own validation)
    if isinstance(payload, dict) and action_type in SUPPORTED_TYPES:
        if action_type == "message":
            _validate_message_payload(payload, errors)
        elif action_type == "event":
            # New structured event validation
            date_str = payload.get("date")
            if not date_str:
                errors.append("payload.date is required for event action")
            else:
                try:
                    datetime.strptime(date_str, "%Y-%m-%d")
                except Exception:
                    errors.append("payload.date must be in format YYYY-MM-DD")

            time_str = payload.get("time")
            if time_str:
                try:
                    datetime.strptime(time_str, "%H:%M")
                except Exception:
                    errors.append("payload.time must be in format HH:MM")

            if not payload.get("description"):
                errors.append("payload.description is required for event action")

            if "repeat" in payload and payload["repeat"] not in [
                "none",
                "daily",
                "weekly",
                "monthly",
                "always",
            ]:
                errors.append(
                    "payload.repeat must be one of: none, daily, weekly, monthly, always"
                )
        elif action_type == "command":
            _validate_command_payload(payload, errors)
        elif action_type == "memory":
            _validate_memory_payload(payload, errors)

    return len(errors) == 0, errors


# Cache for discovered action plugins
_ACTION_PLUGINS: List[Any] | None = None


def _load_action_plugins() -> List[Any]:
    """Load classes under plugins/ that implement get_supported_actions."""
    global _ACTION_PLUGINS
    if _ACTION_PLUGINS is not None:
        log_debug(f"[action_parser] Returning cached plugins ({len(_ACTION_PLUGINS)})")
        return _ACTION_PLUGINS

    _ACTION_PLUGINS = []
    base_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "plugins")
    for root, _dirs, files in os.walk(base_path):
        for file in files:
            if not file.endswith(".py") or file.startswith("__"):
                continue
            rel = os.path.relpath(
                os.path.join(root, file), os.path.dirname(os.path.dirname(__file__))
            )
            module_name = rel[:-3].replace(os.sep, ".")
            try:
                module = importlib.import_module(module_name)
            except Exception as e:
                log_error(f"[action_parser] Failed to import {module_name}: {repr(e)}")
                continue
            log_debug(f"[action_parser] Checking module: {module_name}")
            for _name, obj in inspect.getmembers(module, inspect.isclass):
                # Support both method names for backward compatibility
                if hasattr(obj, "get_supported_actions") or hasattr(
                    obj, "get_supported_action_types"
                ):
                    try:
                        instance = obj()
                        log_debug(f"[action_parser] Loaded plugin: {obj.__name__}")

                        # Start the plugin if it has a start method
                        if hasattr(instance, "start"):
                            try:
                                if asyncio.iscoroutinefunction(instance.start):
                                    # Try to get the running loop and schedule start
                                    try:
                                        loop = asyncio.get_running_loop()
                                        if loop and loop.is_running():
                                            loop.create_task(instance.start())
                                            log_debug(
                                                f"[action_parser] Started async plugin: {obj.__name__}"
                                            )
                                        else:
                                            log_debug(
                                                f"[action_parser] No running loop for plugin: {obj.__name__}"
                                            )
                                    except RuntimeError:
                                        log_debug(
                                            f"[action_parser] No event loop for async start: {obj.__name__}"
                                        )
                                else:
                                    instance.start()
                                    log_debug(
                                        f"[action_parser] Started sync plugin: {obj.__name__}"
                                    )
                            except Exception as e:
                                log_error(
                                    f"[action_parser] Error starting plugin {obj.__name__}: {repr(e)}"
                                )

                    except Exception as e:
                        log_error(f"[action_parser] Failed to init {obj}: {repr(e)}")
                        continue
                    # Avoid duplicate plugin registration
                    if any(isinstance(p, obj) for p in _ACTION_PLUGINS):
                        log_warning(
                            f"[action_parser] Duplicate plugin {obj.__name__} ignored"
                        )
                    else:
                        _ACTION_PLUGINS.append(instance)
    log_debug(
        "[action_parser] Plugins loaded: "
        + ", ".join([p.__class__.__name__ for p in _ACTION_PLUGINS])
    )
    return _ACTION_PLUGINS


def _plugins_for(action_type: str) -> List[Any]:
    plugins = []
    for plugin in _load_action_plugins():
        try:
            # Support both method names for backward compatibility
            if hasattr(plugin, "get_supported_actions"):
                supported = plugin.get_supported_actions()
            elif hasattr(plugin, "get_supported_action_types"):
                supported = plugin.get_supported_action_types()
            else:
                continue

            if action_type in supported:
                plugins.append(plugin)
        except Exception as e:
            log_error(f"[action_parser] Error querying plugin {plugin}: {repr(e)}")
    return plugins


def set_available_plugins(interfaces, llm_engine, plugins):
    """Set available plugins and their details for the action parser."""
    global ACTIVE_INTERFACES, ACTIVE_LLM_ENGINE, AVAILABLE_PLUGINS

    # Set active interfaces
    ACTIVE_INTERFACES = set(interfaces)
    log_info("[action_parser] Active interfaces set.")

    # Set active LLM engine
    ACTIVE_LLM_ENGINE = llm_engine
    log_info(f"[action_parser] Active LLM engine: {ACTIVE_LLM_ENGINE}")

    # Set available plugins
    AVAILABLE_PLUGINS = plugins
    log_info("[action_parser] Available plugins set.")


# Variables to store the state
ACTIVE_INTERFACES = set()
ACTIVE_LLM_ENGINE = None
AVAILABLE_PLUGINS = []


async def _handle_plugin_action(
    action: Dict[str, Any], context: Dict[str, Any], bot, original_message
):
    action_type = action.get("type")
    for plugin in _plugins_for(action_type):
        if hasattr(plugin, "execute_action"):
            try:
                result = plugin.execute_action(action, context, bot, original_message)
                if inspect.iscoroutine(result):
                    await result
            except Exception as e:
                log_error(
                    f"[action_parser] Error executing {action_type} with {plugin}: {repr(e)}"
                )
        else:
            log_warning(f"[action_parser] Plugin {plugin} has no execute_action()")
    if not _plugins_for(action_type):
        log_warning(f"[action_parser] No plugin supports action type '{action_type}'")


async def run_action(action: Any, context: Dict[str, Any], bot, original_message):
    """Validate and execute a single action or list of actions."""
    log_debug(f"[action_parser] run_action called with: {action}")
    if isinstance(action, list):
        for act in action:
            await run_action(act, context, bot, original_message)
        return

    valid, errors = validate_action(action)
    if not valid:
        log_warning(f"[action_parser] Invalid action: {errors}")
        return

    action_type = action.get("type")
    log_debug(f"[action_parser] Executing action type: {action_type}")

    # Use plugin system for all action types (including messages)
    await _handle_plugin_action(action, context, bot, original_message)


async def run_actions(actions: Any, context: Dict[str, Any], bot, original_message):
    """Execute multiple actions in sequence.

    If ``actions`` is a single dict, it will be wrapped in a list.
    Invalid actions are logged and skipped.
    """
    if actions is None:
        return

    if isinstance(actions, dict):
        actions = [actions]
    elif not isinstance(actions, list):
        log_error("[action_parser] run_actions expects a list or dict")
        return

    log_debug(f"[action_parser] run_actions called with {len(actions)} actions")
    log_debug(f"[action_parser] Actions: {actions}")

    for idx, action in enumerate(actions):
        try:
            valid, errors = validate_action(action)
            if not valid:
                log_warning(f"[action_parser] Skipping invalid action {idx}: {errors}")
                continue
            log_debug(f"[action_parser] Running action {idx}: {action.get('type')}")
            await run_action(action, context, bot, original_message)
        except Exception as e:
            log_error(f"[action_parser] Error executing action {idx}: {repr(e)}")

    # After all actions processed, mark scheduled event as delivered if applicable
    event_id = context.get("event_id") or getattr(original_message, "event_id", None)
    if event_id:
        try:
            from core import event_dispatcher

            event_dispatcher.event_completed(event_id)
        except Exception as e:
            log_warning(
                f"[action_parser] Failed to clear processing flag for event {event_id}: {e}"
            )


async def parse_action(action: dict, bot, message):
    """Parse and execute a single action."""
    log_debug(f"[action_parser] Received action: {action}")

    action_type = action.get("type")
    interface = action.get("interface")
    payload = action.get("payload")

    if not action_type or not payload:
        log_warning("[action_parser] Invalid action structure: missing type or payload")
        return

    log_debug(
        "[action_parser] Action type: "
        + str(action_type)
        + ", Interface: "
        + str(interface)
        + ", Payload: "
        + str(payload)
    )

    # Use centralized action plugin system for all action types
    action_plugins = _plugins_for(action_type)
    if action_plugins:
        for plugin in action_plugins:
            try:
                if hasattr(plugin, "execute_action"):
                    result = plugin.execute_action(action, {}, bot, message)
                    if inspect.iscoroutine(result):
                        await result
                elif hasattr(plugin, "handle_custom_action"):
                    await plugin.handle_custom_action(action_type, payload)
                else:
                    log_warning(
                        f"[action_parser] Plugin {plugin.__class__.__name__} lacks execute_action/handle_custom_action methods"
                    )
            except Exception as e:
                log_error(
                    f"[action_parser] Error delegating {action_type} to plugin {plugin.__class__.__name__}: {repr(e)}"
                )
        return

    log_warning(
        f"[action_parser] No plugin supports action type '{action_type}' — no plugin handler found"
    )


async def initialize_core(notify_fn=None):
    """Initialize and log all core components."""
    from core.core_initializer import core_initializer

    return await core_initializer.initialize_all(notify_fn=notify_fn)


def get_action_plugin_instructions() -> dict[str, str]:
    """Gather prompt instructions from all action plugins."""
    instructions: dict[str, str] = {}
    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_actions") and hasattr(plugin, "get_prompt_instructions"):
                supported = plugin.get_supported_actions()
                prompt_map = plugin.get_prompt_instructions()
                for action in supported:
                    if action in prompt_map:
                        instructions[action] = prompt_map[action]
                    else:
                        log_warning(
                            f"[action_parser] Plugin {plugin.__class__.__name__} missing prompt instructions for '{action}'"
                        )
    except Exception as e:
        log_error(f"[action_parser] Error collecting plugin prompt instructions: {repr(e)}")

    return instructions


__all__ = [
    "run_action",
    "run_actions",
    "parse_action",
    "validate_action",
    "initialize_core",
    "get_action_plugin_instructions",
]

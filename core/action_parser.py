# core/action_parser.py
"""Execute actions generated by Rekku."""

import asyncio
import inspect
import os
import json
import time
from collections import deque
from types import SimpleNamespace
from datetime import datetime
from typing import Any, Dict, List, Tuple, Optional

from core.logging_utils import log_debug, log_info, log_warning, log_error
from core.prompt_engine import build_full_json_instructions

# Global dictionary to track retry attempts per chat/message thread for the corrector
CORRECTOR_RETRIES = int(os.getenv("CORRECTOR_RETRIES", "2"))
_retry_tracker = {}


ERROR_RETRY_POLICY = {
    "description": (
        "If you receive a system_message of type 'error' with the phrase 'Please repeat your "
        "previous message, not this very prompt, but your previous reply, corrected. If that was a "
        "web search please use the content to reply with your own words.' you must automatically "
        "re-send the exact same JSON you sent previously, but with the part indicated as invalid corrected."
    ),
    "steps": [
        "1. Identify which part of your last sent JSON caused the error (e.g. an unsupported action type or missing parameter).",
        "2. Create a new JSON that is identical to the one you previously sent, except for correcting ONLY the invalid part.",
        "3. Do not add, remove or reorder any other actions or payload content.",
        "4. Re-submit the corrected JSON immediately (without waiting for user instructions).",
    ],
}


def _get_retry_key(message):
    """Generate a unique key for tracking retries based on chat/thread.

    Preserve chat_id and message_thread_id as strings (no numeric coercion),
    since external interfaces may represent identifiers as strings. This
    ensures consistent retry keys without changing original identifier types.
    """
    chat_id = getattr(message, "chat_id", None)
    thread_id = getattr(message, "message_thread_id", None)

    def _norm(value):
        if value is None:
            return "none"
        # Keep original representation as string (don't coerce to int)
        return str(value)

    return f"{_norm(chat_id)}_{_norm(thread_id)}"


def _should_retry(message, max_retries: int = CORRECTOR_RETRIES) -> bool:
    """Check if we should attempt retry for this message context."""
    retry_key = _get_retry_key(message)
    current_time = time.time()

    # Clean up old retry entries (older than 5 minutes)
    cutoff_time = current_time - 300  # 5 minutes
    keys_to_remove = [k for k, (count, timestamp) in _retry_tracker.items() if timestamp < cutoff_time]
    for key in keys_to_remove:
        del _retry_tracker[key]

    # Check current retry count
    retry_count, _ = _retry_tracker.get(retry_key, (0, current_time))
    return retry_count < max_retries


def _increment_retry(message):
    """Increment retry count for this message context."""
    retry_key = _get_retry_key(message)
    current_time = time.time()
    retry_count, _ = _retry_tracker.get(retry_key, (0, current_time))
    _retry_tracker[retry_key] = (retry_count + 1, current_time)
    return retry_count + 1


async def corrector(errors: list, failed_actions: list, bot, message):
    """Handle action parsing errors by requesting LLM to fix them."""

    if not _should_retry(message, max_retries=CORRECTOR_RETRIES):
        retry_key = _get_retry_key(message)
        retry_count, _ = _retry_tracker.get(retry_key, (0, 0))
        log_warning(
            f"[corrector] Max retries ({retry_count}) reached for action correction. Giving up."
        )
        return

    if not hasattr(message, "chat_id") or message.chat_id is None:
        log_warning(
            f"[corrector] Cannot request correction: invalid chat_id in message: {getattr(message, 'chat_id', 'None')}"
        )
        return

    retry_count = _increment_retry(message)

    # If the LLM provided no original reply, avoid requesting a correction loop.
    original_reply = getattr(message, "original_text", getattr(message, "text", "")) or ""
    if not original_reply.strip():
        log_warning(f"[corrector] Aborting correction: original LLM reply empty for chat {getattr(message, 'chat_id', None)}")
        # Try to notify the chat/trainer that no correction can be requested
        try:
            if hasattr(bot, "send_message"):
                await bot.send_message(chat_id=message.chat_id, text="⚠️ Unable to request correction: original LLM reply was empty.")
        except Exception as e:
            log_debug(f"[corrector] Failed to notify about empty original reply: {e}")
        return

    # If the original reply already contains a system_message, likely we're in a correction loop.
    if '"system_message"' in original_reply:
        log_warning(f"[corrector] Aborting correction: original reply already contains system_message for chat {getattr(message, 'chat_id', None)}")
        try:
            if hasattr(bot, "send_message"):
                await bot.send_message(chat_id=message.chat_id, text="⚠️ Correction aborted: LLM returned a system error response repeatedly.")
        except Exception as e:
            log_debug(f"[corrector] Failed to notify about repeated system_message: {e}")
        return

    error_summary = "\n".join([f"- {err}" for err in errors[:5]])

    message_text = (
        f"{error_summary}\n"
        "Please repeat your previous message, not this very prompt, but your previous reply, corrected. "
        "If that was a web search please use the content to reply with your own words."
    )
    full_json = build_full_json_instructions()
    correction_payload = {
        "system_message": {
            "type": "error",
            "message": message_text,
            "your_reply": getattr(message, "original_text", getattr(message, "text", "")),
            "full_json_instructions": full_json,
            "error_retry_policy": ERROR_RETRY_POLICY,
        }
    }
    correction_prompt = json.dumps(correction_payload, ensure_ascii=False)

    log_warning(f"[corrector] {error_summary}")
    log_info(
        f"[corrector] Requesting action correction from LLM (attempt {retry_count}/{CORRECTOR_RETRIES})"
    )

    try:
        from core import plugin_instance

        correction_message = SimpleNamespace()
        correction_message.chat_id = message.chat_id
        correction_message.text = correction_prompt
        correction_message.message_thread_id = getattr(message, "message_thread_id", None)
        correction_message.date = getattr(message, "date", datetime.utcnow())
        correction_message.from_user = getattr(message, "from_user", None)
        
        # Ensure from_user has an id attribute
        if correction_message.from_user and not hasattr(correction_message.from_user, 'id'):
            correction_message.from_user.id = getattr(message, "from_user", SimpleNamespace()).id if hasattr(getattr(message, "from_user", None), 'id') else None

        llm_plugin = getattr(plugin_instance, "plugin", None)
        if llm_plugin and hasattr(llm_plugin, "handle_incoming_message"):
            await llm_plugin.handle_incoming_message(bot, correction_message, correction_prompt)
        else:
            log_warning("[corrector] No LLM plugin available for action correction")

    except Exception as e:
        log_error(f"[corrector] Failed to request action correction: {e}")

# Cache for interface actions discovered via the interface registry
_INTERFACE_ACTIONS: Dict[str, str] | None = None


def _load_interface_actions() -> Dict[str, str]:
    """Return a mapping of action_type -> interface_name from registered interfaces."""
    global _INTERFACE_ACTIONS

    if _INTERFACE_ACTIONS is not None:
        log_debug(
            f"[action_parser] 🔄 Returning cached interface actions ({len(_INTERFACE_ACTIONS)})"
        )
        return _INTERFACE_ACTIONS

    try:
        from core.core_initializer import INTERFACE_REGISTRY
    except Exception as e:  # pragma: no cover - registry unavailable
        log_warning(f"[action_parser] Unable to access INTERFACE_REGISTRY: {e}")
        INTERFACE_REGISTRY = {}

    actions: Dict[str, str] = {}
    for name, iface in INTERFACE_REGISTRY.items():
        try:
            if hasattr(iface, "get_supported_actions"):
                supported = iface.get_supported_actions()
                if isinstance(supported, dict):
                    for act in supported.keys():
                        actions[act] = name

            # Dynamic check for supported actions
            if hasattr(iface, "get_supported_action_types"):
                action_types = iface.get_supported_action_types()
                if isinstance(action_types, (list, set)):
                    for act in action_types:
                        actions[act] = name

        except Exception as e:  # pragma: no cover - defensive
            log_debug(f"[action_parser] Error inspecting interface {name}: {e}")

    _INTERFACE_ACTIONS = actions
    return actions


def get_supported_action_types() -> set[str]:
    """Return all supported action types discovered from plugins and interfaces."""
    supported_types: set[str] = set()

    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_action_types"):
                plugin_types = plugin.get_supported_action_types()
                if isinstance(plugin_types, (list, set)):
                    supported_types.update(plugin_types)
            elif hasattr(plugin, "get_supported_actions"):
                plugin_actions = plugin.get_supported_actions()
                if isinstance(plugin_actions, dict):
                    supported_types.update(plugin_actions.keys())
                elif isinstance(plugin_actions, (list, set, tuple)):
                    supported_types.update(plugin_actions)
    except Exception as e:
        log_warning(f"[action_parser] Error discovering action types: {e}")

    try:
        supported_types.update(_load_interface_actions().keys())
    except Exception as e:  # pragma: no cover - defensive
        log_debug(f"[action_parser] Error loading interface actions: {e}")

    return supported_types


def _validate_payload(action_type: str, payload: dict, errors: List[str]) -> None:
    """Validate payload using plugins or interfaces that support the action type."""
    try:
        for plugin in _load_action_plugins():
            supports_action = False
            try:
                if hasattr(plugin, "get_supported_action_types"):
                    if action_type in plugin.get_supported_action_types():
                        supports_action = True
                elif hasattr(plugin, "get_supported_actions"):
                    actions = plugin.get_supported_actions()
                    if isinstance(actions, dict) and action_type in actions:
                        supports_action = True
                    elif isinstance(actions, (list, set, tuple)) and action_type in actions:
                        supports_action = True
            except Exception as e:
                log_debug(f"[action_parser] Error checking plugin support for {action_type}: {e}")
                continue

            if supports_action:
                if hasattr(plugin, "validate_payload"):
                    try:
                        plugin_errors = plugin.validate_payload(action_type, payload)
                        if plugin_errors and isinstance(plugin_errors, list):
                            errors.extend(plugin_errors)
                            log_debug(
                                f"[action_parser] Plugin {plugin.__class__.__name__} added {len(plugin_errors)} validation errors"
                            )
                    except Exception as e:
                        log_warning(
                            f"[action_parser] Error validating payload with plugin {plugin.__class__.__name__}: {e}"
                        )
                elif hasattr(plugin, "validate_action"):
                    try:
                        action_dict = {"type": action_type, "payload": payload}
                        plugin_errors = plugin.validate_action(action_dict)
                        if plugin_errors and isinstance(plugin_errors, list):
                            errors.extend(plugin_errors)
                            log_debug(
                                f"[action_parser] Plugin {plugin.__class__.__name__} added {len(plugin_errors)} validation errors"
                            )
                    except Exception as e:
                        log_warning(
                            f"[action_parser] Error validating action with plugin {plugin.__class__.__name__}: {e}"
                        )
                else:
                    # Plugin doesn't have validation - that's OK, skip
                    log_debug(
                        f"[action_parser] Plugin {plugin.__class__.__name__} supports {action_type} but has no validation method"
                    )

        # Interface-based validation
        iface_name = _load_interface_actions().get(action_type)
        if iface_name:
            try:
                from core.core_initializer import INTERFACE_REGISTRY
                iface = INTERFACE_REGISTRY.get(iface_name)
                if iface and hasattr(iface, "validate_payload"):
                    iface_errors = iface.validate_payload(action_type, payload)
                    if iface_errors and isinstance(iface_errors, list):
                        errors.extend(iface_errors)
                        log_debug(
                            f"[action_parser] Interface {iface_name} added {len(iface_errors)} validation errors"
                        )
            except Exception as e:  # pragma: no cover - defensive
                log_warning(
                    f"[action_parser] Error validating payload with interface {iface_name}: {e}"
                )
    except Exception as e:
        log_error(f"[action_parser] Error during payload validation: {e}")


def validate_action(action: dict, context: dict = None, original_message=None) -> Tuple[bool, List[str]]:
    """Validate an action dictionary.

    Parameters
    ----------
    action : dict
        Dictionary describing an action.
    context : dict, optional
        Context information for interface inference.
    original_message : optional
        Original message for interface inference.

    Returns
    -------
    tuple[bool, list[str]]
        A tuple containing a boolean validity flag and a list of error messages.
    """

    errors: List[str] = []

    # Ignore optional description fields from the LLM
    if isinstance(action, dict) and "description" in action:
        action = {k: v for k, v in action.items() if k != "description"}

    if not isinstance(action, dict):
        return False, ["action must be a dict"]

    # Validate action type - with specific action names, interface is implicit
    supported_types = get_supported_action_types()
    action_type = action.get("type")
    if not action_type:
        errors.append("Missing 'type'")
    elif action_type not in supported_types:
        # Check if any plugin or interface supports this action type
        errors.append(
            f"Unsupported type '{action_type}' - no plugin or interface found to handle it"
        )

    payload = action.get("payload")
    if payload is None:
        errors.append("Missing 'payload'")
    elif not isinstance(payload, dict):
        errors.append("'payload' must be a dict")

    # Dynamic validation - delegate to plugins or interfaces that support this action type
    if isinstance(payload, dict) and action_type in supported_types:
        _validate_payload(action_type, payload, errors)

        if _is_restricted_action(action_type):
            mode = os.getenv("RESTRICT_ACTIONS", "on").lower()
            if mode == "on":
                errors.append(f"Action '{action_type}' is restricted")
            elif mode == "trainer_only":
                user_id = getattr(getattr(original_message, "from_user", None), "id", None)
                try:
                    from core.config import TELEGRAM_TRAINER_ID
                except Exception:
                    TELEGRAM_TRAINER_ID = None  # type: ignore
                if user_id is not None and TELEGRAM_TRAINER_ID and user_id != TELEGRAM_TRAINER_ID:
                    errors.append(f"Action '{action_type}' is restricted to trainer")

    return len(errors) == 0, errors


# Cache for discovered action plugins
_ACTION_PLUGINS: List[Any] | None = None


def _load_action_plugins() -> List[Any]:
    """Return plugin instances registered with the core initializer."""
    global _ACTION_PLUGINS
    if _ACTION_PLUGINS is not None:
        log_debug(f"[action_parser] 🔄 Returning cached plugins ({len(_ACTION_PLUGINS)})")
        return _ACTION_PLUGINS

    try:
        from core.core_initializer import PLUGIN_REGISTRY
    except Exception as e:
        log_warning(f"[action_parser] Unable to access PLUGIN_REGISTRY: {e}")
        PLUGIN_REGISTRY = {}

    _ACTION_PLUGINS = list(PLUGIN_REGISTRY.values())
    log_info(f"[action_parser] 🔍 Loaded {len(_ACTION_PLUGINS)} plugin(s) from registry")
    return _ACTION_PLUGINS

def _plugins_for(action_type: str) -> List[Any]:
    plugins = []
    loaded_plugins = _load_action_plugins()
    log_debug(
        f"[action_parser] _plugins_for({action_type}): Checking {len(loaded_plugins)} loaded plugins"
    )

    for plugin in loaded_plugins:
        try:
            supported = None

            if hasattr(plugin, "get_supported_action_types"):
                action_types = plugin.get_supported_action_types()
                log_debug(
                    f"[action_parser] Plugin {plugin.__class__.__name__}.get_supported_action_types(): {action_types}"
                )
                if action_types and action_type in action_types:
                    plugins.append(plugin)
                    log_debug(
                        f"[action_parser] ✅ Plugin {plugin.__class__.__name__} supports {action_type} (via action_types)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] ⚡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

            if hasattr(plugin, "get_supported_actions"):
                actions_dict = plugin.get_supported_actions()
                log_debug(
                    f"[action_parser] Plugin {plugin.__class__.__name__}.get_supported_actions(): {actions_dict}"
                )
                if isinstance(actions_dict, dict) and action_type in actions_dict:
                    plugins.append(plugin)
                    log_debug(
                        f"[action_parser] ✅ Plugin {plugin.__class__.__name__} supports {action_type} (via actions_dict)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] ⚡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

        except Exception as e:
            log_error(f"[action_parser] Error querying plugin {plugin}: {repr(e)}")

    try:
        from core.core_initializer import INTERFACE_REGISTRY
    except Exception as e:  # pragma: no cover - defensive
        log_error(f"[action_parser] Error loading INTERFACE_REGISTRY: {e}")
        INTERFACE_REGISTRY = {}

    for name, iface in INTERFACE_REGISTRY.items():
        try:
            supported = None
            if hasattr(iface, "get_supported_action_types"):
                action_types = iface.get_supported_action_types()
                log_debug(
                    f"[action_parser] Interface {name}.get_supported_action_types(): {action_types}"
                )
                if action_types and action_type in action_types:
                    plugins.append(iface)
                    log_debug(
                        f"[action_parser] ✅ Interface {name} supports {action_type} (via action_types)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] ⚡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

            if hasattr(iface, "get_supported_actions"):
                actions_dict = iface.get_supported_actions()
                log_debug(
                    f"[action_parser] Interface {name}.get_supported_actions(): {actions_dict}"
                )
                if isinstance(actions_dict, dict) and action_type in actions_dict:
                    plugins.append(iface)
                    log_debug(
                        f"[action_parser] ✅ Interface {name} supports {action_type} (via actions_dict)"
                    )
                    # Optimization: Stop searching for message actions after first match
                    if action_type.startswith("message_"):
                        log_debug(f"[action_parser] ⚡ Optimization: Stopping search for message action {action_type} after first match")
                        break
                    continue

            log_debug(
                f"[action_parser] ❌ Interface {name} does not support {action_type}"
            )
        except Exception as e:
            log_error(f"[action_parser] Error querying interface {name}: {repr(e)}")

    log_debug(
        f"[action_parser] _plugins_for({action_type}): Found {len(plugins)} supporting plugins"
    )
    return plugins


def set_available_plugins(interfaces, llm_engine, plugins):
    """Set available plugins and their details for the action parser."""
    global ACTIVE_INTERFACES, ACTIVE_LLM_ENGINE, AVAILABLE_PLUGINS

    # Set active interfaces
    ACTIVE_INTERFACES = set(interfaces)
    log_info("[action_parser] Active interfaces set.")

    # Set active LLM engine
    ACTIVE_LLM_ENGINE = llm_engine
    log_info(f"[action_parser] Active LLM engine: {ACTIVE_LLM_ENGINE}")

    # Set available plugins
    AVAILABLE_PLUGINS = plugins
    log_info("[action_parser] Available plugins set.")


# Variables to store the state
ACTIVE_INTERFACES = set()
ACTIVE_LLM_ENGINE = None
AVAILABLE_PLUGINS = []


async def _handle_plugin_action(
    action: Dict[str, Any], context: Dict[str, Any], bot, original_message
):
    action_type = action.get("type")
    iface_target = action.get("interface")
    
    log_info(f"[action_parser] 🎯 Handling action: type={action_type}, interface={iface_target}")
    
    plugins = _plugins_for(action_type)
    log_info(f"[action_parser] 🔍 Found {len(plugins)} plugins for action type '{action_type}'")
    
    if not plugins:
        log_info(
            f"[action_parser] 📭 No plugin found for action type '{action_type}', attempting interface dispatch"
        )

        # Determine target interface from action or registry mapping
        iface_name = iface_target or _load_interface_actions().get(action_type)
        
        # If interface not found, try to refresh the interface actions cache
        if not iface_name and action_type.startswith("message_"):
            global _INTERFACE_ACTIONS
            _INTERFACE_ACTIONS = None  # Force refresh
            iface_name = _load_interface_actions().get(action_type)

        try:
            from core.core_initializer import INTERFACE_REGISTRY

            interface = INTERFACE_REGISTRY.get(iface_name) if iface_name else None
            if interface and action_type.startswith("message") and hasattr(interface, "send_message"):
                payload = action.get("payload", {})
                log_info(
                    f"[action_parser] ✉️ Dispatching message action to interface '{iface_name}'"
                )
                try:
                    result = interface.send_message(payload, original_message)
                    if inspect.iscoroutine(result):
                        await result
                    return None
                except Exception as e:
                    log_error(
                        f"[action_parser] ❌ Error executing {action_type} via interface {iface_name}: {repr(e)}"
                    )
                return
        except Exception as e:  # pragma: no cover - defensive
            log_warning(f"[action_parser] Interface dispatch failed: {e}")

        log_error(f"[action_parser] ❌ No plugin or interface supports action type '{action_type}'")
        return
    
    for plugin in plugins:
        plugin_iface = getattr(
            plugin.__class__, "get_interface_id", lambda: plugin.__class__.__name__.lower()
        )()

        log_info(
            f"[action_parser] 🔌 Checking plugin: {plugin.__class__.__name__} (plugin_interface: {plugin_iface})"
        )

        if iface_target and plugin_iface != iface_target:
            log_info(
                f"[action_parser] ⏭️ Skipping plugin {plugin_iface} (target: {iface_target})"
            )
            continue

        if hasattr(plugin, "execute_action"):
            try:
                payload = action.get("payload", {})
                if not isinstance(payload, dict):
                    payload = vars(payload)
                new_action = {**action, "payload": payload}
                log_info(
                    f"[action_parser] 🚀 Delegating action to {plugin.__class__.__name__}: type={action_type} interface={plugin_iface}"
                )
                log_debug(f"[action_parser] 📦 Action payload: {payload}")

                result = plugin.execute_action(
                    new_action, context, bot, original_message
                )
                if inspect.iscoroutine(result):
                    await result
                log_info(
                    f"[action_parser] ✅ Successfully executed action via {plugin_iface}"
                )
                return None
            except Exception as e:
                log_error(
                    f"[action_parser] ❌ Error executing {action_type} with {plugin.__class__.__name__}: {repr(e)}"
                )
                import traceback
                log_error(f"[action_parser] 📄 Full traceback: {traceback.format_exc()}")
        else:
            log_warning(
                f"[action_parser] ⚠️ Plugin {plugin.__class__.__name__} has no execute_action() method"
            )

    # No matching plugin found - collect error for auto-correction
    available_interfaces = list(ACTIVE_INTERFACES) if ACTIVE_INTERFACES else ["No interfaces registered"]
    error_msg = f"Interface '{iface_target}' not found for action '{action_type}'. Available interfaces: {', '.join(available_interfaces)}"
    
    log_error(f"[action_parser] 💥 No plugin matched interface '{iface_target}' for action '{action_type}'")
    return {"error": error_msg, "action": action, "available_interfaces": available_interfaces}


async def run_action(action: Any, context: Dict[str, Any], bot, original_message):
    """Validate and execute a single action or list of actions."""
    log_info(f"[action_parser] 🎬 run_action called with action: {action}")
    
    if isinstance(action, list):
        log_info(f"[action_parser] 📋 Processing action list with {len(action)} items")
        return await run_actions(action, context, bot, original_message)

    valid, errors = validate_action(action, context, original_message)
    if not valid:
        error_msg = f"Invalid action: {errors}"
        log_error(f"[action_parser] ❌ {error_msg}")
        return {"error": error_msg}

    action_type = action.get("type")
    action_interface = action.get("interface")
    log_info(f"[action_parser] 🚀 Executing action: type={action_type}, interface={action_interface}")

    # Use plugin system for all action types (including messages)
    result = await _handle_plugin_action(action, context, bot, original_message)
    return result


async def run_actions(actions: Any, context: Dict[str, Any], bot, original_message):
    """Execute multiple actions in sequence.

    If ``actions`` is a single dict, it will be wrapped in a list.
    Invalid actions are logged and errors collected for auto-correction.
    
    Returns:
        dict: {"processed": [successful_actions], "errors": [error_messages]}
    """
    if actions is None:
        return {"processed": [], "errors": []}

    if isinstance(actions, dict):
        actions = [actions]
    elif not isinstance(actions, list):
        error_msg = "[action_parser] run_actions expects a list or dict"
        log_error(error_msg)
        return {"processed": [], "errors": [error_msg]}

    log_debug(f"[action_parser] run_actions called with {len(actions)} actions")
    log_debug(f"[action_parser] Actions: {actions}")

    processed_actions = []
    collected_errors = []
    action_outputs: List[Dict[str, Any]] = []
    terminal_seen = False

    for idx, action in enumerate(actions):
        try:
            action_type = action.get("type")

            # Halt processing of subsequent non-terminal actions until the LLM
            # has seen the outputs from executed terminal commands.
            if terminal_seen and action_type != "terminal":
                log_info(
                    "[action_parser] ⏸️ Waiting for LLM response before executing remaining actions"
                )
                break

            valid, errors = validate_action(action, context, original_message)
            if not valid:
                error_msg = f"Invalid action {idx}: {errors}"
                log_warning(f"[action_parser] Skipping {error_msg}")
                collected_errors.append(error_msg)
                continue

            log_debug(f"[action_parser] Running action {idx}: {action_type}")
            result = await run_action(action, context, bot, original_message)

            # Check if run_action returned error info
            if isinstance(result, dict) and "error" in result:
                collected_errors.append(result["error"])
            else:
                processed_actions.append(action)

                if action_type == "terminal" and isinstance(result, str):
                    terminal_seen = True
                    action_outputs.append(
                        {
                            "type": "terminal",
                            "command": action.get("payload", {}).get("command", ""),
                            "output": result,
                        }
                    )

        except Exception as e:
            error_msg = f"Error executing action {idx}: {repr(e)}"
            log_error(f"[action_parser] {error_msg}")
            collected_errors.append(error_msg)

    # After all actions processed, mark scheduled event as delivered if applicable
    event_id = context.get("event_id") or getattr(original_message, "event_id", None)
    if event_id:
        try:
            from core import db

            if await db.mark_event_delivered(event_id):
                log_info(f"[action_parser] Event {event_id} marked delivered")
            else:
                log_warning(f"[action_parser] Failed to mark event {event_id} delivered")
        except Exception as e:
            log_warning(f"[action_parser] Error marking event {event_id} delivered: {e}")
        try:
            from core import event_dispatcher

            event_dispatcher.event_completed(event_id)
        except Exception as e:
            log_warning(
                f"[action_parser] Failed to clear processing flag for event {event_id}: {e}"
            )

    if action_outputs:
        interface_name = context.get("interface", "telegram_bot")
        if interface_name == "telegram":
            interface_name = "telegram_bot"

        response_context = {
            "chat_id": getattr(original_message, "chat_id", None),
            "message_id": getattr(original_message, "message_id", None),
            "interface_name": interface_name,
            "message_thread_id": getattr(original_message, "message_thread_id", None),
        }

        try:
            from core.auto_response import request_llm_delivery

            await request_llm_delivery(
                action_outputs=action_outputs,
                original_context=response_context,
                action_type="terminal",
            )
        except Exception as e:
            log_warning(
                f"[action_parser] Failed to request LLM delivery for action outputs: {e}"
            )

    if collected_errors:
        await corrector(collected_errors, actions, bot, original_message)

    return {
        "processed": processed_actions,
        "errors": collected_errors,
        "action_outputs": action_outputs,
    }


async def parse_action(action: dict, bot, message):
    """Parse and execute a single action."""
    log_debug(f"[action_parser] Received action: {action}")

    action_type = action.get("type")
    interface = action.get("interface")
    payload = action.get("payload")

    if not action_type or not payload:
        log_warning("[action_parser] Invalid action structure: missing type or payload")
        return

    log_debug(
        "[action_parser] Action type: "
        + str(action_type)
        + ", Interface: "
        + str(interface)
        + ", Payload: "
        + str(payload)
    )

    # First allow the active LLM plugin to handle custom actions
    import core.plugin_instance as plugin_instance
    llm_plugin = getattr(plugin_instance, "plugin", None)
    if llm_plugin:
        try:
            supported = []
            if hasattr(llm_plugin, "get_supported_action_types"):
                supported = llm_plugin.get_supported_action_types()
            elif hasattr(llm_plugin, "get_supported_actions"):
                acts = llm_plugin.get_supported_actions()
                if isinstance(acts, dict):
                    supported = list(acts.keys())
            if action_type in supported and hasattr(llm_plugin, "handle_custom_action"):
                await llm_plugin.handle_custom_action(action_type, payload)
                return
        except Exception:
            pass

    # Use centralized action plugin system for all other action types
    action_plugins = _plugins_for(action_type)
    if action_plugins:
        action_handled = False
        for plugin in action_plugins:
            try:
                if hasattr(plugin, "execute_action"):
                    result = plugin.execute_action(action, {}, bot, message)
                    if inspect.iscoroutine(result):
                        await result
                    action_handled = True
                    log_debug(f"[action_parser] Action {action_type} handled by {plugin.__class__.__name__}")
                    break  # Stop after first successful handler
                elif hasattr(plugin, "handle_custom_action"):
                    await plugin.handle_custom_action(action_type, payload)
                    action_handled = True
                    log_debug(f"[action_parser] Action {action_type} handled by {plugin.__class__.__name__} (custom)")
                    break  # Stop after first successful handler
                else:
                    log_warning(
                        f"[action_parser] Plugin {plugin.__class__.__name__} lacks execute_action/handle_custom_action methods"
                    )
            except Exception as e:
                log_error(
                    f"[action_parser] Error delegating {action_type} to plugin {plugin.__class__.__name__}: {repr(e)}"
                )
        
        if action_handled:
            log_debug(f"[action_parser] Action {action_type} successfully handled")
        else:
            log_warning(f"[action_parser] No plugin successfully handled action {action_type}")
        return

    log_warning(
        f"[action_parser] No plugin supports action type '{action_type}' — no plugin handler found"
    )


async def initialize_core(notify_fn=None):
    """Initialize and log all core components."""
    from core.core_initializer import core_initializer

    return await core_initializer.initialize_all(notify_fn=notify_fn)


def get_action_plugin_instructions() -> dict[str, dict]:
    """Gather prompt instructions from all action plugins."""
    instructions: dict[str, str] = {}
    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_actions") and hasattr(plugin, "get_prompt_instructions"):
                supported = plugin.get_supported_actions()
                for action in supported:
                    try:
                        instr = plugin.get_prompt_instructions(action)
                        if instr:
                            instructions[action] = instr
                    except Exception:
                        log_warning(
                            f"[action_parser] Plugin {plugin.__class__.__name__} missing prompt instructions for '{action}'"
                        )
    except Exception as e:
        log_error(f"[action_parser] Error collecting plugin prompt instructions: {repr(e)}")

    return instructions


async def gather_static_injections(message=None, context_memory=None) -> dict:
    """Collect static injections from plugins supporting the ``static_inject`` action.

    Parameters
    ----------
    message : optional
        The original message associated with the prompt. Passed to plugins that
        accept it for participant resolution.
    context_memory : optional
        Memory structure containing recent chat messages. Also passed to
        plugins if they accept it.
    """

    injections: dict = {}
    try:
        for plugin in _load_action_plugins():
            try:
                supported = False
                if hasattr(plugin, "get_supported_action_types"):
                    types = plugin.get_supported_action_types()
                    if types and "static_inject" in types:
                        supported = True
                elif hasattr(plugin, "get_supported_actions"):
                    acts = plugin.get_supported_actions()
                    if isinstance(acts, dict):
                        supported = "static_inject" in acts
                    elif isinstance(acts, (list, set, tuple)):
                        supported = "static_inject" in acts
                if not supported or not hasattr(plugin, "get_static_injection"):
                    continue

                # Pass message and context_memory if the plugin expects them
                try:
                    result = plugin.get_static_injection(message, context_memory)
                except TypeError:
                    result = plugin.get_static_injection()

                if inspect.iscoroutine(result):
                    result = await result
                if isinstance(result, dict):
                    injections.update(result)
            except Exception as e:
                log_error(
                    f"[action_parser] Error gathering static injection from {plugin.__class__.__name__}: {e}"
                )
    except Exception as e:
        log_error(f"[action_parser] Error collecting static injections: {e}")
    return injections


def _is_restricted_action(action_type: str) -> bool:
    """Return True if the action is marked as restricted."""
    try:
        for plugin in _load_action_plugins():
            if hasattr(plugin, "get_supported_actions"):
                actions = plugin.get_supported_actions()
                if isinstance(actions, dict):
                    meta = actions.get(action_type)
                    if isinstance(meta, dict) and meta.get("restricted"):
                        return True
    except Exception:
        pass
    try:  # Check interface actions as well
        from core.core_initializer import INTERFACE_REGISTRY
        for iface in INTERFACE_REGISTRY.values():
            if hasattr(iface, "get_supported_actions"):
                actions = iface.get_supported_actions()
                if isinstance(actions, dict):
                    meta = actions.get(action_type)
                    if isinstance(meta, dict) and meta.get("restricted"):
                        return True
    except Exception:
        pass
    return False


__all__ = [
    "run_action",
    "run_actions",
    "parse_action",
    "validate_action",
    "initialize_core",
    "get_action_plugin_instructions",
    "gather_static_injections",
]

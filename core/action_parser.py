# core/action_parser.py
"""Execute actions generated by Rekku."""

import asyncio
import importlib
import inspect
import os
from collections import deque
from types import SimpleNamespace
from datetime import datetime
from typing import Any, Dict, List

from core.action_validator import validate_action
import core.plugin_instance as plugin_instance
from core.logging_utils import log_debug, log_info, log_warning, log_error


# Cache for discovered action plugins
_ACTION_PLUGINS: List[Any] | None = None


def _load_action_plugins() -> List[Any]:
    """Load classes under plugins/ that implement get_supported_actions."""
    global _ACTION_PLUGINS
    if _ACTION_PLUGINS is not None:
        return _ACTION_PLUGINS

    _ACTION_PLUGINS = []
    base_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "plugins")
    for root, _dirs, files in os.walk(base_path):
        for file in files:
            if not file.endswith(".py") or file.startswith("__"):
                continue
            rel = os.path.relpath(os.path.join(root, file), os.path.dirname(os.path.dirname(__file__)))
            module_name = rel[:-3].replace(os.sep, ".")
            try:
                module = importlib.import_module(module_name)
            except Exception as e:
                log_error(f"[action_parser] Failed to import {module_name}: {e}")
                continue
            for _name, obj in inspect.getmembers(module, inspect.isclass):
                if hasattr(obj, "get_supported_actions"):
                    try:
                        instance = obj()
                    except Exception as e:
                        log_error(f"[action_parser] Failed to init {obj}: {e}")
                        continue
                    _ACTION_PLUGINS.append(instance)
    return _ACTION_PLUGINS


def _plugins_for(action_type: str) -> List[Any]:
    plugins = []
    for plugin in _load_action_plugins():
        try:
            supported = plugin.get_supported_actions()
            if action_type in supported:
                plugins.append(plugin)
        except Exception as e:
            log_error(f"[action_parser] Error querying plugin {plugin}: {e}")
    return plugins


async def _handle_message_action(action: Dict[str, Any], context: Dict[str, Any], bot, original_message):
    payload = action.get("payload", {})
    text = payload.get("text", "")
    log_debug(f"[action_parser] Handling message action: {text}")

    # Build fake message object mimicking telegram.Message
    msg = SimpleNamespace()
    msg.text = text
    msg.chat_id = getattr(original_message, "chat_id", None)
    msg.chat = getattr(original_message, "chat", SimpleNamespace(id=msg.chat_id, type="private"))
    msg.from_user = getattr(original_message, "from_user", None)
    msg.message_id = int(datetime.utcnow().timestamp() * 1000) % 1_000_000
    msg.date = datetime.utcnow()
    msg.reply_to_message = None

    history = context.get("context", {}).get("messages", [])
    context_memory = {msg.chat_id: deque(history, maxlen=10)}

    try:
        await plugin_instance.handle_incoming_message(bot, msg, context_memory)
    except Exception as e:
        log_error(f"[action_parser] Error in _handle_message_action: {e}")


async def _handle_event_action(action: Dict[str, Any], _context: Dict[str, Any], _bot, _original_message):
    payload = action.get("payload", {})
    log_debug(f"[action_parser] EVENT placeholder: {payload}")


async def _handle_plugin_action(action: Dict[str, Any], context: Dict[str, Any], bot, original_message):
    action_type = action.get("type")
    for plugin in _plugins_for(action_type):
        if hasattr(plugin, "execute_action"):
            try:
                result = plugin.execute_action(action, context, bot, original_message)
                if inspect.iscoroutine(result):
                    await result
            except Exception as e:
                log_error(f"[action_parser] Error executing {action_type} with {plugin}: {e}")
        else:
            log_warning(f"[action_parser] Plugin {plugin} has no execute_action()")
    if not _plugins_for(action_type):
        log_warning(f"[action_parser] No plugin supports action type '{action_type}'")


async def run_action(action: Any, context: Dict[str, Any], bot, original_message):
    """Validate and execute a single action or list of actions."""
    if isinstance(action, list):
        for act in action:
            await run_action(act, context, bot, original_message)
        return

    valid, errors = validate_action(action)
    if not valid:
        log_warning(f"[action_parser] Invalid action: {errors}")
        return

    action_type = action.get("type")

    if action_type == "message":
        await _handle_message_action(action, context, bot, original_message)
    elif action_type == "event":
        await _handle_event_action(action, context, bot, original_message)
    else:
        await _handle_plugin_action(action, context, bot, original_message)


async def run_actions(actions: Any, context: Dict[str, Any], bot, original_message):
    """Execute multiple actions in sequence.

    If ``actions`` is a single dict, it will be wrapped in a list.
    Invalid actions are logged and skipped.
    """
    if actions is None:
        return

    if isinstance(actions, dict):
        actions = [actions]
    elif not isinstance(actions, list):
        log_error("[action_parser] run_actions expects a list or dict")
        return

    for idx, action in enumerate(actions):
        try:
            valid, errors = validate_action(action)
            if not valid:
                log_warning(f"[action_parser] Skipping invalid action {idx}: {errors}")
                continue
            log_debug(f"[action_parser] Running action {idx}: {action.get('type')}")
            await run_action(action, context, bot, original_message)
        except Exception as e:
            log_error(f"[action_parser] Error executing action {idx}: {e}")


async def parse_action(action: dict, bot, message):
    """Parse and execute a single action."""
    log_debug(f"[action_parser] Received action: {action}")

    action_type = action.get("type")
    interface = action.get("interface")
    payload = action.get("payload")

    if not action_type or not interface or not payload:
        log_warning("[action_parser] Invalid action structure: missing type, interface, or payload")
        return

    log_debug(f"[action_parser] Action type: {action_type}, Interface: {interface}, Payload: {payload}")

    if action_type == "message":
        target = payload.get("target")
        text = payload.get("text")
        thread_id = payload.get("thread_id")

        if not text:
            log_warning("[action_parser] Invalid message action: missing text")
            return

        # If target is missing or invalid, use the original message's chat_id as fallback
        if not target:
            target = getattr(message, "chat_id", None)
            log_debug(f"[action_parser] No target specified, using original chat_id: {target}")
        
        # If thread_id is missing but original message has one, use it as fallback
        if not thread_id and hasattr(message, "chat_id"):
            original_thread_id = getattr(message, "message_thread_id", None)
            if original_thread_id:
                thread_id = original_thread_id
                log_debug(f"[action_parser] No thread_id specified, using original thread_id: {thread_id}")
        
        # Additional validation for target
        if not target:
            log_warning("[action_parser] No valid target found, cannot send message")
            return

        try:
            log_debug(f"[action_parser] Sending message to {target} (thread_id: {thread_id}) with text: {text}")
            
            # Prepare kwargs for send_message
            send_kwargs = {"chat_id": target, "text": text}
            if thread_id:
                send_kwargs["message_thread_id"] = thread_id
            
            await bot.send_message(**send_kwargs)
            log_debug(f"[action_parser] Message successfully sent to {target} (thread: {thread_id})")
        except Exception as e:
            log_error(f"[action_parser] Failed to send message to {target} (thread: {thread_id}): {e}")
            # Try fallback to original chat if target was different
            if hasattr(message, "chat_id") and target != message.chat_id:
                try:
                    fallback_thread_id = getattr(message, "message_thread_id", None)
                    fallback_kwargs = {"chat_id": message.chat_id, "text": text}
                    if fallback_thread_id:
                        fallback_kwargs["message_thread_id"] = fallback_thread_id
                    
                    log_debug(f"[action_parser] Retrying with original chat_id: {message.chat_id} (thread: {fallback_thread_id})")
                    await bot.send_message(**fallback_kwargs)
                    log_debug(f"[action_parser] Message successfully sent to fallback chat: {message.chat_id} (thread: {fallback_thread_id})")
                except Exception as fallback_error:
                    log_error(f"[action_parser] Fallback also failed: {fallback_error}")
    else:
        plugin = getattr(plugin_instance, "plugin", None)
        if plugin and hasattr(plugin, "handle_custom_action"):
            try:
                await plugin.handle_custom_action(action_type, payload)
            except Exception as e:
                log_error(
                    f"[action_parser] Error delegating {action_type} to plugin: {e}"
                )
        else:
            log_warning(
                f"[action_parser] Unsupported action type: {action_type} (no plugin handler)"
            )


__all__ = ["run_action", "run_actions", "parse_action"]
